; vim: filetype=asm sw=4 ts=4 autoindent expandtab shiftwidth=4 et:

; *********************************************************************
;
;  MINT Minimal Interpreter
;
;  GNU GENERAL PUBLIC LICENSE              Version 3, 29 June 2007
;
;  see the LICENSE file in this repo for more information
;
;  original for the Z80, by Ken Boak, John Hardy and Craig Jones.
;
;  original for the 6502, by Alvaro G. S. Barcellos, 2023
;
;  agsb@ see the disclaimer file in this repo for more information.
;
;  agsb@ star(tm) date 10/10/2023
;
; *********************************************************************

;--------------------------------------------------------
;
;  ca65 assembler specifics
;
;--------------------------------------------------------

; identifiers

;.case +

; enable features

;.feature c_comments

;.feature string_escapes

;.feature org_per_seg

;.feature dollar_is_pc

;.feature pc_assignment

; enable 6502 mode

;.p02

;--------------------------------------------------------
;
;   constants, as must be.
;
;--------------------------------------------------------

    TRUE        = 1
    FALSE       = 0

    CR  = 13
    LF  = 10
    BS  = 9
    ETX = 3
    NUL = 0

    ; stack size 
    STKSIZE = $30

    ; size page
    PAGE = $100

    ; group size
    GRPSIZE = $40

    ; groups for defs, could be more
    NUMGRPS = 5

;----------------------------------------------------------------------

    ; stacks at zero page, 24 word deep
    ZERO_PAGE_STACK = 1

    ; include extra functions
    FULL_STACK_CODES = 1

    ; define emulator mode
    EMULATOR = 1

    ; define test for emulator debug
    test = 1

;----------------------------------------------------------------------
;.segment "ZERO"
org  0

; return stack with 24 words
ds STKSIZE, $0
dat_zero:

; data stack with 24 words
ds  STKSIZE, $0
ret_zero:

; instruction pointer
ins_ptr:    dw $0
; index for data stack
dat_indx:    db $0
; index for return stack
ret_indx:    db $0
; copycat
nest: 	db $0
echo:   db $0
; pseudo registers
tos:    dw $0
nos:    dw $0
wrk:    dw $0
tmp:    dw $0

;
;----------------------------------------------------------------------
;.segment "VECTORS"

org $FFFA

dw init
dw init
dw init

;----------------------------------------------------------------------
;.segment "CODE"

; start of RAM
org $200

tib:
    ds PAGE, $00

; mint variables, 26 plus 6 from z
vsys:
    ds GRPSIZE, $00

; user variable, 26 plus 6 from z
vars:
    ds GRPSIZE, $00

; user function groups, each with 26 plus 6 from Z
defs:
    ds GRPSIZE * NUMGRPS, $00

; internals

vEdited:
    db $0

vByteMode:
    db $0

; heap must be here !
heap:
    dw $0

;----------------------------------------------------------------------
; aliases

vS0      =  vsys + $00     ;    a  ; start of data stack
vBase16  =  vsys + $02     ;    b  ; base16 flag
vTIBPtr  =  vsys + $04     ;    c  ; TIBPtr variable
vDefs    =  vsys + $08     ;    d  ; reference for group user functions
;        =  vsys + $0a     ;    e  ;
vR0      =  vsys + $0c     ;    f  ; start of return stack
vNext    =  vsys + $0e     ;    g  ; next routine dispatcher
vHeap    =  vsys + $10     ;    h  ; heap ptr variable

; the address of stacks are hardcoded, any change do no apply
dStack = vS0
rStack = vR0
; any change will cause unexpected behavior
;HEAP = heap
;DEFS = defs

;----------------------------------------------------------------------
;.segment "ONCE"

; start of ROM
org $F000

init:
    jmp mint_
    db 'M','I','N','T','@','6','5','0','2',0

;----------------------------------------------------------------------
; 25/10/2023, using lib6502, -M E000
.if EMULATOR

hitchar:

getchar:
    ;jsr $E010
    lda $E000
    rts

putchar:
    ;jsr $E020
    sta $E000
    rts

.endif

.ifn EMULATOR

;----------------------------------------------------------------------
;    depends on hardware, ACIA 6551 common
;----------------------------------------------------------------------
    CIA       =  $E000   ; The base address of the 6551 ACIA.
    CIA_DATA  =  CIA+0   ; Its data I/O register
    CIA_RX    =  CIA+0   ; Its data I/O register
    CIA_TX    =  CIA+0   ; Its data I/O register
    CIA_STAT  =  CIA+1   ; Its  status  register
    CIA_COMM  =  CIA+2   ; Its command  register
    CIA_CTRL  =  CIA+3   ; Its control  register

;----------------------------------------------------------------
; setup thru 6551
setchar:
pcia_init:
    ; reset CIA
    lda #0
    sta CIA_STAT
    ; %0001 1110 =  9600 baud, external receiver, 8 bit , 1 stop bit
    ; %0001 1111 = 19200 baud, external receiver, 8 bit , 1 stop bit
    lda #$1F
    sta CIA_CTRL
    ; %0000 1011 = no parity, normal mode, RTS low, INT disable, DTR low
    lda #$0B
    sta CIA_COMM
    rts

;----------------------------------------------------------------
;   verify thru 6551, no waits
hitchar:
acia_ht:
; verify
    lda CIA_STAT
    and #8
    beq i_nak
i_ack:
    lda #$01
    rts
i_nak:
    lda #$00
    rts

;----------------------------------------------------------------
;   receive a byte thru 6551, waits
getchar:
acia_rx:
; verify
    lda CIA_STAT
    and #8
    ; beq @ends
    beq acia_rx
; receive
    lda CIA_RX
    rts

;----------------------------------------------------------------
;   transmit a byte thru 6551, waits
putchar:
acia_tx:
; verify
    pha
    lda CIA_STAT
    and #16
    ; beq @ends
    beq acia_tx
; transmit
    pla
    sta CIA_TX
    rts

.endif

;----------------------------------------------------------------------
; get a char
key_:
    jsr getchar
keyk:
    sta tos + 0
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; put a char
emit_:
    jsr spull
    lda tos + 0
    jsr putchar
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; hit a char ?
keyq_:
    jsr hitchar
    clc
    bcc keyk

; ---------------------------------------------------------------------
; Forth like functions
; to keep code safe by not using "fall throught".
; uses A, Y, X caller must saves.
; needs 2 levels of hardware stack
; uses 4 bytes in page zero as temporary
; uses 6 bytes in memory for internal use
; ---------------------------------------------------------------------

; ---------------------------------------------------------------------
;   data stack stuff

keep_: ; to push
    ; ldx dat_indx
    dex
    dex
    stx dat_indx
    rts

lose_: ; to pull
    ; ldx dat_indx
    inx
    inx
    stx dat_indx
    rts

spush:
push_:
    ldx dat_indx
    lda tos + 0
    sta dat_zero - 2, x
    lda tos + 1
    sta dat_zero - 1, x
    jmp keep_

spull:
pull_:
    ldx dat_indx
    lda dat_zero + 0, x
    sta tos + 0
    lda dat_zero + 1, x
    sta tos + 1
    jmp lose_

.if FULL_STACK_CODES
push2_:
    ldx dat_indx
    lda nos + 0
    sta dat_zero - 4, x
    lda nos + 1
    sta dat_zero - 3, x
    lda tos + 0
    sta dat_zero - 2, x
    lda tos + 1
    sta dat_zero - 1, x
    jsr keep_
    jmp keep_
.endif

take2:
pull2_:
    ldx dat_indx
    lda dat_zero + 0, x
    sta tos + 0
    lda dat_zero + 1, x
    sta tos + 1
    lda dat_zero + 2, x
    sta nos + 0
    lda dat_zero + 3, x
    sta nos + 1
    jsr lose_
    jmp lose_

drop_:
    ldx dat_indx
    jsr lose_
    ; rts
    jmp (vNext)

dup_:
    ldx dat_indx
    lda dat_zero + 0, x
    sta dat_zero - 2
    lda dat_zero + 1, x
    sta dat_zero - 1
    jsr keep_
    ; rts
    jmp (vNext)

over_:
    ldx dat_indx
    lda dat_zero + 2, x
    sta dat_zero - 2
    lda dat_zero + 3, x
    sta dat_zero - 1
    jsr keep_
    ; rts
    jmp (vNext)

swap_:
    ldx dat_indx
    lda dat_zero + 0, x
    sta dat_zero - 2
    lda dat_zero + 1, x
    sta dat_zero - 1
    lda dat_zero + 2, x
    sta dat_zero + 0
    lda dat_zero + 3, x
    sta dat_zero + 1
    lda dat_zero - 2, x
    sta dat_zero + 2
    lda dat_zero - 1, x
    sta dat_zero + 3
    ; rts
    jmp (vNext)

rot_:
    ldx dat_indx
    lda dat_zero + 4, x
    sta dat_zero - 2
    lda dat_zero + 5, x
    sta dat_zero - 1
    lda dat_zero + 2, x
    sta dat_zero + 4
    lda dat_zero + 3, x
    sta dat_zero + 5
    lda dat_zero + 0, x
    sta dat_zero + 2
    lda dat_zero + 1, x
    sta dat_zero + 3
    lda dat_zero - 2, x
    sta dat_zero + 0
    lda dat_zero - 1, x
    sta dat_zero + 1
    ; rts
    jmp (vNext)

and_:
    ldx dat_indx
    lda dat_zero + 0, x
    and dat_zero + 2, x
    sta dat_zero + 2, x
    lda dat_zero + 1, x
    and dat_zero + 3, x
    sta dat_zero + 3, x
    jmp drop_

or_:
    ldx dat_indx
    lda dat_zero + 0, x
    ora dat_zero + 2, x
    sta dat_zero + 2, x
    lda dat_zero + 1, x
    ora dat_zero + 3, x
    sta dat_zero + 3, x
    jmp drop_

xor_:
    ldx dat_indx
    lda dat_zero + 0, x
    eor dat_zero + 2, x
    sta dat_zero + 2, x
    lda dat_zero + 1, x
    eor dat_zero + 3, x
    sta dat_zero + 3, x
    jmp drop_

cpt_:
    ldx dat_indx
    sec
    tya
    sbc dat_zero + 0, x
    sta dat_zero + 0, x
    sec
    tya
    sbc dat_zero + 1, x
    sta dat_zero + 1, x
    ; rts
    jmp (vNext)

neg_:
    lda #$00
    tay
    jmp cpt_

inv_:
    lda #$FF
    tay
    jmp cpt_

sub_:
    ldx dat_indx
    sec
    lda dat_zero + 2, x
    sbc dat_zero + 0, x
    sta dat_zero + 2, x
    lda dat_zero + 3, x
    sbc dat_zero + 1, x
    sta dat_zero + 3, x
    jmp drop_

add_:
    ldx dat_indx
    clc
    lda dat_zero + 2, x
    adc dat_zero + 0, x
    sta dat_zero + 2, x
    lda dat_zero + 3, x
    adc dat_zero + 1, x
    sta dat_zero + 3, x
    jmp drop_

cmp_:
    ldx dat_indx
    sec
    lda dat_zero + 2, x
    sbc dat_zero + 0, x
    lda dat_zero + 3, x
    sbc dat_zero + 1, x
    rts

eq_:
    jsr cmp_
    beq true2_
    bne false2_

lt_:
    jsr cmp_
    bmi true2_
    bpl false2_

gt_:
    jsr cmp_
    bmi false2_
    beq false2_
    bpl true2_

same2_:
    ldx dat_indx
    sta dat_zero + 2, x
    sta dat_zero + 3, x
    jmp drop_

false2_:
    lda #(FALSE)
    beq same2_

true2_:
    lda #(FALSE - 1)
    bne same2_

shl_:
    ldx dat_indx
    asl dat_zero + 0, x
    rol dat_zero + 1, x
    ; rts
    jmp (vNext)

shr_:
    ldx dat_indx
    lsr dat_zero + 0, x
    ror dat_zero + 1, x
    ; rts
    jmp (vNext)

cto_:
    jsr pull2_
    ldy #0
    lda nos + 0
    sta (tos), y
    rts

to_:
    jsr cto_
    iny
    lda nos + 1
    sta (tos), y
    rts

cStore_:
    jsr cto_
    ; rts
    jmp (vNext)

store_:
    jsr to_
    ; rts
    jmp (vNext)

cat_:
    ldx dat_indx
    lda dat_zero + 0, x
    sta tos + 0
    lda dat_zero + 1, x
    sta tos + 1
    ldy #0
    lda (tos), y
    sta dat_zero + 0, x
    rts

at_:
    jsr cat_
    iny
    lda (tos), y
    sta dat_zero + 1, x
    rts

cFetch_:
    jsr cat_
    ; rts
    jmp (vNext)

fetch_:
    jsr at_
    ; rts
    jmp (vNext)

incr_:
    ldx dat_indx
    inc dat_zero + 0, x
    bne ends0
    inc dat_zero + 1, x
ends0:
    ; rts
    jmp (vNext)

decr_:
    ldx dat_indx
    lda dat_zero + 0, x
    bne ends1
    dec dat_zero + 1, x
ends1:
    dec dat_zero + 0, x
    ; rts
    jmp (vNext)

.if FULL_STACK_CODES
jump_:
    ldx dat_indx
    lda dat_zero + 1,x
    pha
    lda dat_zero + 0,x
    pha
    php
    rti

addto_:
    jsr pull2_
    ldy #NUL
    clc
    lda (tos), y
    adc nos + 0
    sta (tos), y
    iny
    lda (tos), y
    adc nos + 1
    sta (tos), y
    ; rts
	jmp (vNext)

subto_:
    jsr pull2_
    ldy #NUL
    sec
    lda (tos), y
    sbc nos + 0
    sta (tos), y
    iny
    lda (tos), y
    sbc nos + 1
    sta (tos), y
    ; rts
	jmp (vNext)
.endif

;----------------------------------------------------------------------
;   return stack stuff

rpush:
rpush_:
    ldx ret_indx
    lda tos + 0
    sta ret_zero - 2, x
    lda tos + 1
    sta ret_zero - 1, x
    dex
    dex
    stx ret_indx
    rts

rpull:
rpull_:
    ldx ret_indx
    lda ret_zero + 0, x
    sta tos + 0
    lda ret_zero + 1, x
    sta tos + 1
    inx
    inx
    stx ret_indx
    rts

.if FULL_STACK_CODES
rshow_:
    ldx ret_indx
    lda ret_zero + 0, x
    sta tos + 0
    lda ret_zero + 1, x
    sta tos + 1
    jsr push_
    ; rts
    jmp (vNext)
.endif

r2s_:
    jsr rpull_
    jsr push_
    ; rts
    jmp (vNext)

s2r_:
    jsr pull_
    jsr rpush_
    ; rts
    jmp (vNext)

;----------------------------------------------------------------------
; prepare for mult or divd
opin:
    ldx dat_indx
    ; pseudo tos
    lda dat_zero + 0, x
    sta wrk + 0
    lda dat_zero + 1, x
    sta wrk + 1
    ; pseudo nos
    lda dat_zero + 2, x
    sta tmp + 0
    lda dat_zero + 3, x
    sta tmp + 1
    ; clear results
    lda #NUL
    sta tos + 0
    sta tos + 1
    sta nos + 0
    sta nos + 1
    ; countdown
    ldy #16
    rts

;----------------------------------------------------------------------
; resume from mult or divd
opout:
    ; copy results
    ldx dat_indx
    lda nos + 0
    sta dat_zero + 0, x
    lda nos + 1
    sta dat_zero + 1, x
    lda tos + 0
    sta dat_zero + 2, x
    lda tos + 1
    sta dat_zero + 3, x
    ; rts
    jmp (vNext)

;----------------------------------------------------------------------
; Divide the top 2 cell of the stack
; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
; dividend divisor -- result remainder
; ( tmp wrk -- nos tos )
div_:
    jsr opin
div1:
    asl tmp + 0
    rol tmp + 1
    rol tos + 0
    rol tos + 1
    sec
    lda tos + 0
    sbc wrk + 0
    tax
    lda tos + 1
    sbc wrk + 1
    bcc div2
    sta tos + 1
    stx tos + 0
    inc tmp + 0
div2:
    ; countdown
    dey
    bne div1
    ; results
    lda tmp + 0
    sta nos + 0
    lda tmp + 1
    sta nos + 1
    ; ends
    jmp opout

;----------------------------------------------------------------------
; 16-bit multiply 16x16, 32 result
; http://codebase64.org/doku.php?id=base:16bit_multiplication_32-bit_product
; ( multiplicand multiplier -- resultMSW resultLSW )
; ( tmp wrk -- nos tos )
mul_:
    jsr opin
mul1:   ;   shift_r:
    ; divide by 2
    lsr wrk + 1
    ror wrk + 0
    bcc mul2
    ; add multiplicand to upper half product
    tax
    clc
    lda tmp + 0
    adc tos + 0
    sta tos + 0
    txa
    adc tmp + 1
mul2:   ;   rotate_r:
    ; rotate partial product upper to low
    ror
    ror tos + 1
    ror nos + 1
    ror nos + 0
    ; countdown
    dey
    bne mul1
    sta tos + 0
    ; ends
    jmp opout

; set overflow bit
slv:
    bit slv1
slv1:
    rts

;----------------------------------------------------------------------
;   MINT
;----------------------------------------------------------------------
; NOOP
aNop_:
nop_:
    ; next
    jmp next

;----------------------------------------------------------------------
; add a byte offset to instruction pointer
add2ps:
; update ip
    clc
    adc ins_ptr + 0
    sta ins_ptr + 0
    bcc add2ps1
    inc ins_ptr + 1
add2ps1:
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
pushps:
    ldx ret_indx
    lda ins_ptr + 0
    sta ret_zero - 2, x
    lda ins_ptr + 1
    sta ret_zero - 1, x
    dex
    dex
    stx ret_indx
    rts

;----------------------------------------------------------------------
pullps:
    ldx ret_indx
    lda ret_zero + 0, x
    sta ins_ptr + 0
    lda ret_zero + 1, x
    sta ins_ptr + 1
    inx
    inx
    stx ret_indx
    rts

;----------------------------------------------------------------------
seekps:
    ldy #NUL
    lda (ins_ptr), y
    inc ins_ptr + 0
    bne seekps1
    inc ins_ptr + 1
seekps1:
    rts

;----------------------------------------------------------------------
heap2nos:
    lda vHeap + 0
    sta nos + 0
    lda vHeap + 1
    sta nos + 1
    rts

;----------------------------------------------------------------------
add2heap:
    clc
    adc vHeap + 0
    sta vHeap + 0
    bcc add2heap1
    inc vHeap + 1
add2heap1:
    rts

;----------------------------------------------------------------------
tib2tos:
    lda #<tib
    sta tos + 0
    lda #>tib
    sta tos + 1
    rts

;----------------------------------------------------------------------
add2tos:
    clc
    adc tos + 0
    sta tos + 0
    bcc add2tos1
    inc tos + 1
add2tos1:
    rts

;----------------------------------------------------------------------
inc2tos:
    inc tos + 0
    bcc inc2tos1
    inc tos + 1
inc2tos1:
    rts

;----------------------------------------------------------------------
; sub
subn2t:
    sec
    lda tos + 0
    sbc nos + 0
    sta tos + 0
    lda tos + 1
    sbc nos + 1
    sta tos + 1
    rts

;----------------------------------------------------------------------
; add
addn2t:
    clc
    lda tos + 0
    adc nos + 0
    sta tos + 0
    lda tos + 1
    adc nos + 1
    sta tos + 1
    rts

;----------------------------------------------------------------------
; add 2x
addt2t:
    asl tos + 0
    sta tos + 0
    rol tos + 1
    sta tos + 1
    rts

;----------------------------------------------------------------------
; $00 to $1F, reserved for macros
; macros could not call macros.
macro:
    sty vTIBPtr + 0 ; maybe spush 
    tay
    lda ctlcodeslo, y
    sta tos + 0
    lda ctlcodeshi, y
    sta tos + 1
    ; bypass offset for rts
    lda #1
    jsr add2tos
    ;
    jsr spush
    jsr enter
    db 92,'G',0
    ldy vTIBPtr + 0 ; maybe spull
    jmp interpret2

;----------------------------------------------------------------------
interpret:
    jsr enter
    db 92,'N',0
    ; fall throught

; used by tests
interpret1:
    lda #NUL
    sta vTIBPtr + 0

interpret2:
    lda #NUL
    sta nest
    tay
    beq interpret4

; calc nesting (a macro might have changed it)
interpret3:
    lda tib, y
    iny
    jsr nesting            ; update nesting value

interpret4:
    cpy #NUL
    bne interpret3
    ; fall throught

;----------------------------------------------------------------------
; loop around waiting for character
; get a line into tib
waitchar:
    jsr tib2tos
    jsr spush
    ; fall throught

;----------------------------------------------------------------------
; get a line into buffer pointer by TOS
gets_:
    ; already
    ldy #NUL
    jsr spull

gets_loop:
    ; limit 254
    cpy #$FE
    beq endstr
    jsr getchar

    ; ge space ?
    cmp #32
    bcs ischar
    ; is it end of string ?
    cmp #$0
    beq endstr
    ; windows CRLF, linux CR, Mac LF
    cmp CR                 ; carriage return ?
    beq iscrlf
    cmp LF                 ; line feed ?
    beq iscrlf

ismacro:
    ; $00 to $1F
    ; y is the position in tib
    ; a is the code
    jmp macro

ischar:
    jsr toTib
    ; nest ?
    jsr nesting
    ; wait for next character
    clc
    bcc gets_loop

iscrlf:
    ; just for easy
    lda #CR
    jsr toTib
    lda #LF
    jsr toTib
    ; pending nest ?
    lda nest
    bne gets_loop

; mark end with etx,
endstr:
    ; mark ETX
    lda #ETX
    sta (tos), y
    iny

    ; update instruction pointer
    lda tos + 0
    sta ins_ptr + 0
    lda tos + 1
    sta ins_ptr + 1

    ; next
    jmp next

; maximum 254 chars
toTib:
    ; echo
    jsr putchar
    ; store
    sta (tos), y
    iny
    rts

;----------------------------------------------------------------------
; nesting deep
nesting:
    cmp #'`'
    bne nests
    ; clear bit 7
    lda #$80
    eor nest
    sta nest
    rts
nests:
    bit nest
    bmi nonest
    cmp #':'
    beq nestinc
    cmp #'['
    beq nestinc
    cmp #'('
    beq nestinc
    cmp #';'
    beq nestdec
    cmp #']'
    beq nestdec
    cmp #')'
    beq nestdec
nonest:
    rts
nestinc:
    inc nest
    rts
nestdec:
    dec nest
    rts

;----------------------------------------------------------------------
; prints a asciiz, refered by hardware stack
printStr:
    ; reference
    pla
    sta tos + 0
    pla
    sta tos + 1
    ; asciiz
    ldx #NUL
    jsr putstr
    ; offset
    jsr add2tos
    lda tos + 1
    pha
    lda tos + 0
    pha
    rts

;----------------------------------------------------------------------
; puts a string, ends on `
str_:
    lda ins_ptr + 0
    sta tos + 0
    lda ins_ptr + 1
    sta tos + 1
    ldx #TRUE
    jsr putstr
    ; next
    jmp  (vNext)

;----------------------------------------------------------------------
; puts a string, asciiz
puts_:
    ldx #NUL
    jsr spull
    ; fall throught

;----------------------------------------------------------------------
; prints a asciiz
putstr:
    ldy #NUL
putstr1:
    lda (tos), y
    beq putstr3 ; limit NUL
    cpx #NUL
    beq putstr2
    cmp #'`'        ; ` is the string terminator
    beq putstr3
putstr2:
    jsr putchar
    iny
    bne putstr1 ; limit 256
putstr3:
    tya
    rts

;----------------------------------------------------------------------
; prints number in tos to decimal ASCII
; ps. putchar ends with rts
printdec:
    lda #<10000
    sta nos + 0
    lda #>10000
    sta nos + 1
    jsr nums
    lda #<1000
    sta nos + 0
    lda #>1000
    sta nos + 1
    jsr nums
    lda #<100
    sta nos + 0
    lda #>100
    sta nos + 1
    jsr nums
    lda #<10
    sta nos + 0
    lda #>10
    sta nos + 1
nums:
    ldy #'0'-1
printdec1:
    ; subtract
    iny
    jsr subn2t
    bcc printdec1
    ; restore
    jsr addn2t
    tya
    jmp putchar

;----------------------------------------------------------------------
; prints number in tos to hexadecimal ASCII
printhex:
    lda tos + 1
    jsr printhexbyte
    lda tos + 0
    jsr printhexbyte
    rts

;----------------------------------------------------------------------
; print a 8-bit HEX
printhexbyte:
    tax
    lsr
    ror
    ror
    ror
    jsr printhexbyte1
    txa
printhexbyte1:
    and #$0F
    clc
    ora #$30
    cmp #$3A
    bcc printhexbyte2
    adc #$06
printhexbyte2:
    jmp putchar

;----------------------------------------------------------------------
nul2tos:
    lda #NUL
    sta tos + 0
    sta tos + 1
    rts

;---------------------------------------------------------------------
isdec:
    cmp #'0' + 0
    bcc nak
    cmp #'9' + 1
    bcs nak
    sec
    sbc #'0'
ack:
    clc
    rts
nak:
    sec
    rts

;---------------------------------------------------------------------
ishex:
    ; to upper, clear bit-6
    and #%11011111
    cmp 'A'
    bcc nak
    cmp 'F' + 1
    bcs nak
    sec
    sbc #'A' - 10
    bcc ack

;----------------------------------------------------------------------
; convert a decimal value to binary
dec_:
    jsr nul2tos
dec1:
    jsr seekps
    jsr isdec
    bcs dec2
    jsr add2tos
    sta tos + 1
    jsr mul10
    clc
    bcc dec1
dec2::
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; convert a hexadecimal value to binary
hex_:
    jsr nul2tos
hex1:
    jsr seekps
    jsr isdec
    bcc uval
    jsr ishex
    bcc hex2
    bcs hex3
hex2:
    jsr add2tos
    jsr mul16
    clc
    bcc hex1
hex3:
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; multiply by ten
; 2x + 8x
mul10:
    ; 2x
    jsr addt2t
    lda tos + 0
    sta nos + 0
    lda tos + 1
    sta nos + 1
    ; 2x
    jsr addt2t
    ; 2x
    jsr addt2t
    ; 2x + 8x
    jsr addn2t
    rts


;----------------------------------------------------------------------
; multiply by sixteen
mul16:
    ldy #4
mulx2:
    asl tos + 0
    sta tos + 0
    rol tos + 1
    sta tos + 1
    dey
    bne mulx2
    rts

;----------------------------------------------------------------------
; skip to eol
comment_:
    ldy #NUL
comment1:
    iny
    beq comment2   ; limit 256
    lda (ins_ptr), y
    beq comment2
    cmp #CR
    bne comment1
comment2:
    tya
    jmp add2ps

;----------------------------------------------------------------------
depth_:
    ; stacks are 128 words
    sec
    lda #$FF
    sbc dat_indx
    ; words
    lsr
    sta tos + 0
    lda #NUL
    sta tos + 1
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; print hexadecimal
hdot_:
    jsr spull
    jsr printhex
    jmp dotsp

;----------------------------------------------------------------------
; print decimal
dot_:
    jsr spull
    jsr printdec
    jmp dotsp

;----------------------------------------------------------------------
; print space
dotsp:
    lda #' '
    jsr putchar
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
newln_:
    jsr crlf
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
crlf:
    jsr printStr
    db '\r','\n',0
    rts

;----------------------------------------------------------------------
prompt:
    jsr printStr
    db '\r','\n','>',' ',0
    rts

;----------------------------------------------------------------------
; how many ? 14
printStk_:
    jsr enter
    ;.asciiz  "\\a@2-\\D1-(",$22,"@\\b@\\(,)(.)2-)'"
    ;.asciiz  "\\a@2-\\D1-(14@\\b@\\(,)(.)2-)'"
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; 6502 is memory mapped IO, just read
inPort_:
    jmp cFetch_

;----------------------------------------------------------------------
; 6502 is memory mapped IO, just write
outPort_:
    jmp cStore_

;----------------------------------------------------------------------
; ascii code
charCode_:
    jsr seekps
    sta tos + 0
    lda #NUL
    sta tos + 1
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; copy and update
compNext:

    ; pull heap
    jsr heap2nos

    ; pull value
    jsr spull

    ; byte
    ldy #NUL
    lda tos + 0
    sta (nos), y
    iny

    lda vByteMode + 0
    bne isbm

    ; word
    lda tos + 1
    sta (nos), y
    iny
isbm:

    tya
    jsr add2heap
    ; fall throught

;----------------------------------------------------------------------
; Execute next opcode
next:
opt_:
    jsr seekps
    tay
    lda optcodeslo, y
    sta tos + 0
    lda optcodeshi, y
    sta tos + 1
    jmp(tos)

;----------------------------------------------------------------------
; Execute next alt opcode
alt_:
    jsr seekps
    tay
    lda altcodeslo, y
    sta tos + 0
    lda altcodeshi, y
    sta tos + 1
    jmp(tos)

;----------------------------------------------------------------------
; Parse inline code, must be asciiz
enter:
; pull from system stack
    pla
    sta ins_ptr + 0
    pla
    sta ins_ptr + 1
    inc ins_ptr + 0
    bcc nock
    inc ins_ptr + 1
nock:
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; char 0, Continue from enter
exit_:
    jmp (ins_ptr)

;----------------------------------------------------------------------
; Execute code from data stack
;
exec_:
    jsr spull
    jmp (tos)

;----------------------------------------------------------------------
; Interpret code from data stack
go_:
    jsr pushps
    ; pull ps from data stack
    ldx dat_indx
    lda dat_zero + 0, x
    sta ins_ptr + 0
    lda dat_zero + 1, x
    sta ins_ptr + 1
    inx
    inx
    stx dat_indx
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
ret_:
    jsr pullps
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; Execute code from a user function
call_:

    tax
    jsr pushps
    tax

    jsr lookupDefs

    ; update instruction pointer
    ldy #NUL
    lda (tos), y
    sta ins_ptr + 0
    iny
    lda (tos), y
    sta ins_ptr + 1

    ; next
    jmp (vNext)

;----------------------------------------------------------------------
lookupDeft:
    sta vEdited
    ; fall throught

;----------------------------------------------------------------------
lookupDefs:
    sec
    sbc #'A'
    asl
    tay
    ; offset
    clc
    adc vDefs + 0
    sta tos + 0
    lda #NUL
    adc vDefs + 1
    sta tos + 1
    rts

;----------------------------------------------------------------------
; Copy a user macro to tib
; lookup up def based on a number at data stack
;
editDef_:
    ; which one
    jsr spull

    ; toChar
    clc
    lda #'A'
    adc tos + 0
    tax
    jsr lookupDeft

    ; origin
    lda (tos), y
    sta nos + 0
    iny
    lda (tos), y
    sta nos + 1

    ldy #NUL
    ; empty ?
    lda (nos), y
    beq editDef3    ; is NUL ?
    cmp #';'        ; is end ?
    beq editDef3

    ; copy

    jsr tib2tos

    lda #':'
    jsr writeChar
    lda #1
    jsr add2tos

    txa
    jsr writeChar
    lda #1
    jsr add2tos

    clc
    bcc editDef2

editDef1:
    iny
    beq editDef3

editDef2:
    lda (nos), y
    jsr writeChar
    cmp #';'
    bne editDef1

editDef3:
    lda #<tib
    sta vTIBPtr + 0
    lda #>tib
    sta vTIBPtr + 1
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
writeChar:
    sta (tos), y
    jmp putchar

;----------------------------------------------------------------------
; push an user variable
var_:
    tax
    lda #<vars
    sta tos + 0
    lda #>vars
    sta tos + 1
    jmp a2z

;----------------------------------------------------------------------
; push a mint variable
sysVar_:
    tax
    lda #<vsys
    sta tos + 0
    lda #>vsys
    sta tos + 1
    jmp a2z

;----------------------------------------------------------------------
; push a reference into stack
a2z:
    sec
    txa
    sbc #'a'
    asl
    jsr add2tos
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; skip spaces
nosp:
    jsr seekps
    cmp #' '
    beq nosp
    rts

;----------------------------------------------------------------------
group_:

    jsr spull
    ;-----------------------
    ; multiply by GROUP of 64
    ; swap byte
    lda tos + 0
    sta nos + 1
    lda #NUL
    sta nos + 0
    ; group is 64 bytes
    lsr nos + 1
    ror nos + 0
    lsr nos + 1
    ror nos + 0
    ;-----------------------
    ; save last group
    ldx ret_indx
    lda vDefs + 0
    sta ret_zero - 2, x
    lda vDefs + 1
    sta ret_zero - 1, x
    dex
    dex
    stx ret_indx
    ; update group
    clc
    lda defs + 0
    adc nos + 0
    sta vDefs + 0
    lda defs + 1
    adc nos + 1
    sta vDefs + 1

    ; next
    jmp (vNext)

;----------------------------------------------------------------------
endGroup_:
    ; load last group
    ldx ret_indx
    lda ret_zero + 0, x
    sta vDefs + 0
    lda ret_zero + 1, x
    sta vDefs + 1
    inx
    inx
    stx ret_indx

    ; next
    jmp (vNext)

;----------------------------------------------------------------------
getRef_:
    jsr seekps
    jsr lookupDefs
    jmp fetch_

;----------------------------------------------------------------------
arrDef_:
    lda #FALSE
    beq arrDefs

;----------------------------------------------------------------------
cArrDef_:
    lda #TRUE
    ; fall throught

;----------------------------------------------------------------------
arrDefs:
    ; save array mode
    sta vByteMode

    ; save array start
    ldx dat_indx
    lda vHeap + 0
    sta ret_zero - 2, x
    lda vHeap + 1
    sta ret_zero - 1, x
    dex
    dex
    stx dat_indx

    ; array next
    lda #<compNext
    sta vNext + 0
    lda #>compNext
    sta vNext + 1

    ; next
    jmp next

;----------------------------------------------------------------------
arrEnd_:

    ; start of array
    jsr rpull

    ; save start
    jsr spush

    ; bytes
    sec
    lda vHeap + 0
    sbc tos + 0
    sta tos + 0
    lda vHeap + 1
    sbc tos + 1
    sta tos + 1

    lda vByteMode
    bne isne	
    ; words
    lsr tos + 0
    ror tos + 1
isne:
    ; save size
    jsr spush

    ; common next
    lda #<next
    sta vNext + 0
    lda #>next
    sta vNext + 1

    ; next
    jmp next

;----------------------------------------------------------------------
def_:
    ; must be a A-Z, can't be space
    jsr seekps
    jsr lookupDefs

    ; get heap
    jsr heap2nos

    ; put heap at list
    lda nos + 0
    sta (tos), y
    iny
    lda nos + 1
    sta (tos), y

    ; copy to heap
    ldy #NUL
def1:
    lda (ins_ptr), y
    sta (nos), y
    beq def2
    iny
    beq def2
    cmp #';'
    bne def1
def2:
    ; update heap
    tya
    tax
    jsr add2heap
    ; update instruction pointer
    txa
    jmp add2ps

;----------------------------------------------------------------------
; skip while nest
skipnest:
    lda #$01
    sta nest
skipnext1:
    jsr seekps
    jsr nesting
    lda nest
    bne skipnest1
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; make a frame
mkframe:
    ; alloc a frame
    sec
    lda ret_indx
    sbc #6
    sta ret_indx
    rts

;----------------------------------------------------------------------
; skip a frame
skframe:
    ; alloc a frame
    clc
    lda ret_indx
    adc #6
    sta ret_indx
    rts

;----------------------------------------------------------------------
break_:
    jsr spull
    lda tos + 0
    bne break1
    ; parse frame
    jmp (vNext)
break1:
    jsr skframe
    jmp skipnest

;----------------------------------------------------------------------
; Left parentesis ( begins a loop
begin_:

    ; tos is zero ?
    jsr spull
    lda tos + 0
    beq skipnest

    ; alloc a frame
    jsr mkframe

    ; a frame
    ldx ret_indx
    ; counter
    lda #NUL
    sta ret_zero + 0, x
    sta ret_zero + 1, x
    ; limit
    lda tos + 0
    sta ret_zero + 2, x
    lda tos + 1
    sta ret_zero + 3, x
    ; pointer
    lda ins_ptr + 0
    sta ret_zero + 4, x
    lda ins_ptr + 1
    sta ret_zero + 5, x

    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; Right parentesis ) again a loop
again_:
    ; check if IFTEMode $FFFF
    lda ret_zero + 0, x
    and ret_zero + 1, x
    cmp #$FF
    bne again1

    ; push FALSE
    lda #FALSE
    sta tos + 0
    sta tos + 1
    jsr spush

    ; drop IFTEMmode
    inc ret_indx
    inc ret_indx

    ; next
    jmp (vNext)

again1:
    ; test end
    ldx ret_indx
    lda ret_zero + 2, x
    cmp ret_zero + 0, x
    bne again2
    lda ret_zero + 3, x
    cmp ret_zero + 1, x
    bne again2

    ; end of loop
    jsr skframe

    ; next
    jmp (vNext)

again2:
    ; increase counter
    inc ret_zero + 0, x
    bne again3
    inc ret_zero + 1, x
again3:

    ; return at begin
    lda ret_zero + 4, x
    sta ins_ptr + 0
    lda ret_zero + 5, x
    sta ins_ptr + 1

    ; next
    jmp (vNext)

;----------------------------------------------------------------------
j_:
    sec
    lda ret_indx
    sbc #6
    tax
    jmp index

;----------------------------------------------------------------------
i_:
    ldx ret_indx
    ; fall through

;----------------------------------------------------------------------
index:
    lda ret_zero + 0, x
    sta tos + 0
    lda ret_zero + 1, x
    sta tos + 1
    jsr spush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
ifte_:
    jsr spull
    lda tos + 0
    ora tos + 1
    bne ifte1
    inc tos + 0
    jsr spush
    jmp skipnest
ifte1:
    lda #$FF
    sta tos + 0
    sta tos + 1
    jsr rpush
    ; next
    jmp (vNext)

;----------------------------------------------------------------------
; verify stack
etx_:
    lda dat_indx
    cmp STKSIZE * 2 ; bytes
    bcc ext1
    lda #NUL
ext1:
    jmp interpret

;----------------------------------------------------------------------
iSysVars:
    .word  dStack               ; a vS0
    .word  FALSE                ; b vBase16
    .word  tib                  ; c vTIBPtr
    .word  defs                 ; d vDEFS
    .word  FALSE                ; e vEdited
    .word  rStack               ; f vR0
    .word  next                 ; g dispatcher
    .word  heap                 ; h vHeap
fSysVars:

dysys = fSysVars - iSysVars

;----------------------------------------------------------------------
mint_:

; wise

    sei
    cld
    ldx #$FF
    txs
    inx
    txa
    tay
    cli

    jsr initialize

; safe
    lda #<next
    sta vNext + 0
    lda #>next
    sta vNext + 1

    jsr printStr
    db 'M','I','N','T',' ','6','5','0','2',' ','V','1','.','0','\r','\n',0

    ; auto reset
    jsr interpret

    jmp mint_

;----------------------------------------------------------------------
initialize:

.if 0
; defaults values
    lda #<vars
    sta tos + 0
    lda #>vars
    sta tos + 1
    lda #<vsys
    sta nos + 0
    lda #>vsys
    sta nos + 1
    ldy #GRPSIZE
    lda #NUL
@loop1:
    sta (tos), y
    sta (nos), y
    dey
    sta (tos), y
    sta (nos), y
    dey
    bne @loop1
.endif

; default system values
    lda #<iSysVars
    sta tos + 0
    lda #>iSysVars
    sta tos + 1
    lda #<vsys
    sta nos + 0
    lda #>vsys
    sta nos + 1
    ldy #dysys
inita2:
    lda (tos), y
    sta (nos), y
    dey
    bne inita2

; default function
    lda #<defs
    sta tos + 0
    lda #>defs
    sta tos + 1

    ldx #NUL
inita3:
    ldy #NUL
inita4:
    ; default
    lda #>empty_
    sta (tos), y
    iny
    lda #<empty_
    sta (tos), y
    iny
    cpy #GRPSIZE
    bne inita4

    inx
    cpx #NUMGRPS
    beq inita3

    ; increment
    clc
    lda tos + 0
    adc #GRPSIZE
    sta tos + 0
    bcc inita5
    inc tos + 1
inita5:
    clc
    bcc inita4

    ; all done
    rts

;----------------------------------------------------------------------
;optcodes: parsed by opt_ (next)
;altcodes: parsed by alt_
;ctlcodes: maybe in a future...

; *********************************************************************
; Jump Tables, optmized for single index
; *********************************************************************

; .align $100


; using pla, pla, rts, references must be one less
;----------------------------------------------------------------------
optcodeslo:
   db lsb(exit_)    ;   NUL
   ds lsb(nop_)     ;   SOH
   ds lsb(nop_)     ;   STX
   ds lsb(etx_)     ;   ETX
   ds lsb(nop_)     ;   EOT
   ds lsb(nop_)     ;   ENQ
   ds lsb(nop_)     ;   ACK
   ds lsb(nop_)     ;   BEL
   ds lsb(nop_)     ;   BS
   ds lsb(nop_)     ;   TAB
   ds lsb(nop_)     ;   LF
   ds lsb(nop_)     ;   VT
   ds lsb(nop_)     ;   FF
   ds lsb(nop_)     ;   CR
   ds lsb(nop_)     ;   SO
   ds lsb(nop_)     ;   SI
   ds lsb(nop_)     ;   DLE
   ds lsb(nop_)     ;   DC1
   ds lsb(nop_)     ;   DC2
   ds lsb(nop_)     ;   DC3
   ds lsb(nop_)     ;   DC4
   ds lsb(nop_)     ;   NAK
   ds lsb(nop_)     ;   SYN
   ds lsb(nop_)     ;   ETB
   ds lsb(nop_)     ;   CAN
   ds lsb(nop_)     ;   EM
   ds lsb(nop_)     ;   SUB
   ds lsb(nop_)     ;   ESC
   ds lsb(nop_)     ;   FS
   ds lsb(nop_)     ;   GS
   ds lsb(nop_)     ;   RS
   ds lsb(nop_)     ;   US
   ds lsb(nop_)     ;   SP
   ds lsb(store_)   ;   !
   ds lsb(dup_)     ;   "
   ds lsb(hex_)     ;    #
   ds lsb(swap_)    ;    $
   ds lsb(over_)    ;    %
   ds lsb(and_)     ;    &
   ds lsb(drop_)    ;    '
   ds lsb(begin_)   ;    (
   ds lsb(again_)   ;    )
   ds lsb(mul_)     ;    * multiply 16x16
   ds lsb(add_)     ;    +
   ds lsb(hdot_)    ;    ,
   ds lsb(sub_)     ;    -
   ds lsb(dot_)     ;    .
   ds lsb(div_)     ;    / divide 16x16
   ds lsb(dec_)     ;    0
   ds lsb(dec_)     ;    1
   ds lsb(dec_)     ;    2
   ds lsb(dec_)     ;    3
   ds lsb(dec_)     ;    4
   ds lsb(dec_)     ;    5
   ds lsb(dec_)     ;    6
   ds lsb(dec_)     ;    7
   ds lsb(dec_)     ;    8
   ds lsb(dec_)     ;    9
   ds lsb(def_)     ;    :
   ds lsb(ret_)     ;    ;
   ds lsb(lt_)      ;    <
   ds lsb(eq_)      ;    =
   ds lsb(gt_)      ;    >
   ds lsb(getRef_)  ;    ?
   ds lsb(fetch_)   ;    @
   ds lsb(call_)    ;    A
   ds lsb(call_)    ;    B
   ds lsb(call_)    ;    C
   ds lsb(call_)    ;    D
   ds lsb(call_)    ;    E
   ds lsb(call_)    ;    F
   ds lsb(call_)    ;    G
   ds lsb(call_)    ;    H
   ds lsb(call_)    ;    I
   ds lsb(call_)    ;    J
   ds lsb(call_)    ;    K
   ds lsb(call_)    ;    L
   ds lsb(call_)    ;    M
   ds lsb(call_)    ;    N
   ds lsb(call_)    ;    O
   ds lsb(call_)    ;    P
   ds lsb(call_)    ;    Q
   ds lsb(call_)    ;    R
   ds lsb(call_)    ;    S
   ds lsb(call_)    ;    T
   ds lsb(call_)    ;    U
   ds lsb(call_)    ;    V
   ds lsb(call_)    ;    W
   ds lsb(call_)    ;    X
   ds lsb(call_)    ;    Y
   ds lsb(call_)    ;    Z
   ds lsb(arrDef_)  ;    [
   ds lsb(alt_)     ;    \
   ds lsb(arrEnd_)  ;    ]
   ds lsb(xor_)     ;    ^
   ds lsb(neg_)     ;    _
   ds lsb(str_)     ;    `
   ds lsb(var_)     ;    a
   ds lsb(var_)     ;    b
   ds lsb(var_)     ;    c
   ds lsb(var_)     ;    d
   ds lsb(var_)     ;    e
   ds lsb(var_)     ;    f
   ds lsb(var_)     ;    g
   ds lsb(var_)     ;    h
   ds lsb(var_)     ;    i
   ds lsb(var_)     ;    j
   ds lsb(var_)     ;    k
   ds lsb(var_)     ;    l
   ds lsb(var_)     ;    m
   ds lsb(var_)     ;    n
   ds lsb(var_)     ;    o
   ds lsb(var_)     ;    p
   ds lsb(var_)     ;    q
   ds lsb(var_)     ;    r
   ds lsb(var_)     ;    s
   ds lsb(var_)     ;    t
   ds lsb(var_)     ;    u
   ds lsb(var_)     ;    v
   ds lsb(var_)     ;    w
   ds lsb(var_)     ;    x
   ds lsb(var_)     ;    y
   ds lsb(var_)     ;    z
   ds lsb(shl_)     ;    {
   ds lsb(or_)      ;    |
   ds lsb(shr_)     ;    }
   ds lsb(inv_)     ;    ~
   ds lsb(nop_)     ;    backspace

optcodeshi:
   ds msb(exit_)    ;   NUL
   ds msb(nop_)     ;   SOH
   ds msb(nop_)     ;   STX
   ds msb(etx_)     ;   ETX
   ds msb(nop_)     ;   EOT
   ds msb(nop_)     ;   ENQ
   ds msb(nop_)     ;   ACK
   ds msb(nop_)     ;   BEL
   ds msb(nop_)     ;   BS
   ds msb(nop_)     ;   TAB
   ds msb(nop_)     ;   LF
   ds msb(nop_)     ;   VT
   ds msb(nop_)     ;   FF
   ds msb(nop_)     ;   CR
   ds msb(nop_)     ;   SO
   ds msb(nop_)     ;   SI
   ds msb(nop_)     ;   DLE
   ds msb(nop_)     ;   DC1
   ds msb(nop_)     ;   DC2
   ds msb(nop_)     ;   DC3
   ds msb(nop_)     ;   DC4
   ds msb(nop_)     ;   NAK
   ds msb(nop_)     ;   SYN
   ds msb(nop_)     ;   ETB
   ds msb(nop_)     ;   CAN
   ds msb(nop_)     ;   EM
   ds msb(nop_)     ;   SUB
   ds msb(nop_)     ;   ESC
   ds msb(nop_)     ;   FS
   ds msb(nop_)     ;   GS
   ds msb(nop_)     ;   RS
   ds msb(nop_)     ;   US
   ds msb(nop_)     ;   SP
   ds msb(store_)   ;   !
   ds msb(dup_)     ;   "
   ds msb(hex_)     ;    #
   ds msb(swap_)    ;    $
   ds msb(over_)    ;    %
   ds msb(and_)     ;    &
   ds msb(drop_)    ;    '
   ds msb(begin_)   ;    (
   ds msb(again_)   ;    )
   ds msb(mul_)     ;    *  multiply 16x16, (multpd multpr -- LSW MSW)
   ds msb(add_)     ;    +
   ds msb(hdot_)    ;    ,
   ds msb(sub_)     ;    -
   ds msb(dot_)     ;    .
   ds msb(div_)     ;    /  divide 16x16, (divd divs -- quo rem)
   ds msb(dec_)     ;    0
   ds msb(dec_)     ;    1
   ds msb(dec_)     ;    2
   ds msb(dec_)     ;    3
   ds msb(dec_)     ;    4
   ds msb(dec_)     ;    5
   ds msb(dec_)     ;    6
   ds msb(dec_)     ;    7
   ds msb(dec_)     ;    8
   ds msb(dec_)     ;    9
   ds msb(def_)     ;    :
   ds msb(ret_)     ;    ;
   ds msb(lt_)      ;    lsb( - 1)
   ds msb(eq_)      ;    =
   ds msb(gt_)      ;    >
   ds msb(getRef_)  ;    ?
   ds msb(fetch_)   ;    @
   ds msb(call_)    ;    A
   ds msb(call_)    ;    B
   ds msb(call_)    ;    C
   ds msb(call_)    ;    D
   ds msb(call_)    ;    E
   ds msb(call_)    ;    F
   ds msb(call_)    ;    G
   ds msb(call_)    ;    H
   ds msb(call_)    ;    I
   ds msb(call_)    ;    J
   ds msb(call_)    ;    K
   ds msb(call_)    ;    L
   ds msb(call_)    ;    M
   ds msb(call_)    ;    N
   ds msb(call_)    ;    O
   ds msb(call_)    ;    P
   ds msb(call_)    ;    Q
   ds msb(call_)    ;    R
   ds msb(call_)    ;    S
   ds msb(call_)    ;    T
   ds msb(call_)    ;    U
   ds msb(call_)    ;    V
   ds msb(call_)    ;    W
   ds msb(call_)    ;    X
   ds msb(call_)    ;    Y
   ds msb(call_)    ;    Z
   ds msb(arrDef_)  ;    [
   ds msb(alt_)     ;    \
   ds msb(arrEnd_)  ;    ]
   ds msb(xor_)     ;    ^
   ds msb(neg_)     ;    _
   ds msb(str_)     ;    `
   ds msb(var_)     ;    a
   ds msb(var_)     ;    b
   ds msb(var_)     ;    c
   ds msb(var_)     ;    d
   ds msb(var_)     ;    e
   ds msb(var_)     ;    f
   ds msb(var_)     ;    g
   ds msb(var_)     ;    h
   ds msb(var_)     ;    i
   ds msb(var_)     ;    j
   ds msb(var_)     ;    k
   ds msb(var_)     ;    l
   ds msb(var_)     ;    m
   ds msb(var_)     ;    n
   ds msb(var_)     ;    o
   ds msb(var_)     ;    p
   ds msb(var_)     ;    q
   ds msb(var_)     ;    r
   ds msb(var_)     ;    s
   ds msb(var_)     ;    t
   ds msb(var_)     ;    u
   ds msb(var_)     ;    v
   ds msb(var_)     ;    w
   ds msb(var_)     ;    x
   ds msb(var_)     ;    y
   ds msb(var_)     ;    z
   ds msb(shl_)     ;    {
   ds msb(or_)      ;    |
   ds msb(shr_)     ;    }
   ds msb(inv_)     ;    ~
   ds msb(nop_)     ;    backspace

;----------------------------------------------------------------------
; alternate function codes
ctlcodeslo:
altcodeslo:
   ds lsb(empty_)      ; NUL ^@
   ds lsb(empty_)      ; SOH ^A
   ds lsb(toggleBase_) ; STX ^B
   ds lsb(empty_)      ; ETX ^C
   ds lsb(empty_)      ; EOT ^D
   ds lsb(edit_)       ; ENQ ^E
   ds lsb(empty_)      ; ACK ^F
   ds lsb(empty_)      ; BEL ^G
   ds lsb(backsp_)     ; BS  ^H
   ds lsb(empty_)      ; TAB ^I
   ds lsb(reedit_)     ; LF  ^J
   ds lsb(empty_)      ; VT  ^K
   ds lsb(list_)       ; FF  ^L
   ds lsb(empty_)      ; CR  ^M
   ds lsb(empty_)      ; SO  ^N
   ds lsb(empty_)      ; SI  ^O
   ds lsb(printStack_) ; DLE ^P
   ds lsb(empty_)      ; DC1 ^Q
   ds lsb(empty_)      ; DC2 ^R
   ds lsb(empty_)      ; DC3 ^S
   ds lsb(empty_)      ; DC4 ^T
   ds lsb(empty_)      ; NAK ^U
   ds lsb(empty_)      ; SYN ^V
   ds lsb(empty_)      ; ETB ^W
   ds lsb(empty_)      ; CAN ^X
   ds lsb(empty_)      ; EM  ^Y
   ds lsb(empty_)      ; SUB ^Z
   ds lsb(empty_)      ; ESC ^[
   ds lsb(empty_)      ; FS  ^\
   ds lsb(empty_)      ; GS  ^]
   ds lsb(empty_)      ; RS  ^^
   ds lsb(empty_)      ; US  ^_)
   ds lsb(aNop_)       ; SP  ^`
   ds lsb(cStore_)     ;    !
   ds lsb(aNop_)       ;    "
   ds lsb(aNop_)       ;    #
   ds lsb(aNop_)       ;    $  ( -- adr ) text input ptr
   ds lsb(aNop_)       ;    %
   ds lsb(aNop_)       ;    &
   ds lsb(aNop_)       ;    '
   ds lsb(ifte_)       ;    (  ( b -- )
   ds lsb(aNop_)       ;    )
   ds lsb(aNop_)       ;    *
   ds lsb(incr_)       ;    +  ( adr -- ) increments variable at address
   ds lsb(aNop_)       ;    ,
   ds lsb(decr_)       ;    -  ( adr -- ) decrements variable at address
   ds lsb(aNop_)       ;    .
   ds lsb(aNop_)       ;    /
   ds lsb(aNop_)       ;    0
   ds lsb(aNop_)       ;    1
   ds lsb(aNop_)       ;    2
   ds lsb(aNop_)       ;    3
   ds lsb(aNop_)       ;    4
   ds lsb(aNop_)       ;    5
   ds lsb(aNop_)       ;    6
   ds lsb(aNop_)       ;    7
   ds lsb(aNop_)       ;    8
   ds lsb(aNop_)       ;    9
   ds lsb(aNop_)       ;    :  start defining a macro
   ds lsb(aNop_)       ;    ;
   ds lsb(aNop_)       ;    <
   ds lsb(aNop_)       ;    =
   ds lsb(aNop_)       ;    msb( - 1)
   ds lsb(aNop_)       ;    ?
   ds lsb(cFetch_)     ;    @
   ds lsb(aNop_)       ;    A
   ds lsb(break_)      ;    B
   ds lsb(nop_)        ;    C
   ds lsb(depth_)      ;    D  ( -- val ) depth of data stack
   ds lsb(emit_)       ;    E  ( val -- ) emits a char to output
   ds lsb(aNop_)       ;    F
   ds lsb(go_)         ;    G  ( -- ? ) execute mint definition
   ds lsb(keyq_)       ;    H  ( verify if key hit )
   ds lsb(inPort_)     ;    I  ( port -- val )
   ds lsb(aNop_)       ;    J
   ds lsb(key_)        ;    K  ( -- val )  read a char from input
   ds lsb(aNop_)       ;    L
   ds lsb(aNop_)       ;    M
   ds lsb(newln_)      ;    N  ; prints a newline to output
   ds lsb(outPort_)    ;    O  ( val port -- )
   ds lsb(printStk_)   ;    P  ( -- ) non-destructively prints stack
   ds lsb(aNop_)       ;    Q  quits from Mint REPL
   ds lsb(rot_)        ;    R  ( a b c -- b c a )
   ds lsb(aNop_)       ;    S
   ds lsb(aNop_)       ;    T
   ds lsb(r2s_)        ;    U  S( -- w ) R( w -- )
   ds lsb(s2r_)        ;    V  S( w -- ) R( -- w )
   ds lsb(aNop_)       ;    W   ; ( b -- ) if false, skip to end of loop
   ds lsb(exec_)       ;    X
   ds lsb(aNop_)       ;    Y
   ds lsb(editDef_)    ;    Z
   ds lsb(cArrDef_)    ;    [
   ds lsb(comment_)    ;    \  comment text, skip reading until end of line
   ds lsb(aNop_)       ;    ]
   ds lsb(charCode_)   ;    ^
   ds lsb(aNop_)       ;    _
   ds lsb(aNop_)       ;    `
   ds lsb(sysVar_)     ;    a  ; start of data stack *fixed
   ds lsb(sysVar_)     ;    b  ; base16 flag
   ds lsb(sysVar_)     ;    c  ; TIBPtr variable
   ds lsb(sysVar_)     ;    d  ; vDefs variable
   ds lsb(sysVar_)     ;    e  ;
   ds lsb(sysVar_)     ;    f  ; start of return stack *fixed
   ds lsb(sysVar_)     ;    g  ; next dispatcher
   ds lsb(sysVar_)     ;    h  ; heap ptr variable
   ds lsb(i_)          ;    i  ; returns index of current loop
   ds lsb(j_)          ;    j  ; returns index of outer loop
   ds lsb(sysVar_)     ;    k
   ds lsb(sysVar_)     ;    l
   ds lsb(sysVar_)     ;    m  ( a b -- c ) return the minimum value
   ds lsb(sysVar_)     ;    n
   ds lsb(sysVar_)     ;    o
   ds lsb(sysVar_)     ;    p
   ds lsb(sysVar_)     ;    q
   ds lsb(sysVar_)     ;    r  ; return stack pointer
   ds lsb(sysVar_)     ;    s  ; data stack pointer
   ds lsb(sysVar_)     ;    t
   ds lsb(sysVar_)     ;    u
   ds lsb(sysVar_)     ;    v
   ds lsb(sysVar_)     ;    w
   ds lsb(sysVar_)     ;    x
   ds lsb(sysVar_)     ;    y
   ds lsb(sysVar_)     ;    z
   ds lsb(group_)      ;    {
   ds lsb(aNop_)       ;    |
   ds lsb(endGroup_)   ;    }
   ds lsb(aNop_)       ;    ~
   ds lsb(aNop_)       ;    BS

ctlcodeshi:
altcodeshi:
   ds msb(empty_)      ; NUL ^@
   ds msb(empty_)      ; SOH ^A
   ds msb(toggleBase_) ; STX ^B
   ds msb(empty_)      ; ETX ^C
   ds msb(empty_)      ; EOT ^D
   ds msb(edit_)       ; ENQ ^E
   ds msb(empty_)      ; ACK ^F
   ds msb(empty_)      ; BEL ^G
   ds msb(backsp_)     ; BS  ^H
   ds msb(empty_)      ; TAB ^I
   ds msb(reedit_)     ; LF  ^J
   ds msb(empty_)      ; VT  ^K
   ds msb(list_)       ; FF  ^L
   ds msb(empty_)      ; CR  ^M
   ds msb(empty_)      ; SO  ^N
   ds msb(empty_)      ; SI  ^O
   ds msb(printStack_) ; DLE ^P
   ds msb(empty_)      ; DC1 ^Q
   ds msb(empty_)      ; DC2 ^R
   ds msb(empty_)      ; DC3 ^S
   ds msb(empty_)      ; DC4 ^T
   ds msb(empty_)      ; NAK ^U
   ds msb(empty_)      ; SYN ^V
   ds msb(empty_)      ; ETB ^W
   ds msb(empty_)      ; CAN ^X
   ds msb(empty_)      ; EM  ^Y
   ds msb(empty_)      ; SUB ^Z
   ds msb(empty_)      ; ESC ^[
   ds msb(empty_)      ; FS  ^\
   ds msb(empty_)      ; GS  ^]
   ds msb(empty_)      ; RS  ^^
   ds msb(empty_)      ; US  ^_)
   ds msb(aNop_)       ; SP  ^`
   ds msb(cStore_)     ;    !
   ds msb(aNop_)       ;    "
   ds msb(aNop_)       ;    #
   ds msb(aNop_)       ;    $  ( -- adr ) text input ptr
   ds msb(aNop_)       ;    %
   ds msb(aNop_)       ;    &
   ds msb(aNop_)       ;    '
   ds msb(ifte_)       ;    (  ( b -- )
   ds msb(aNop_)       ;    )
   ds msb(aNop_)       ;    *
   ds msb(incr_)       ;    +  ( adr -- ) increments variable at address
   ds msb(aNop_)       ;    ,
   ds msb(decr_)       ;    -  ( adr -- ) decrements veriable at address
   ds msb(aNop_)       ;    .
   ds msb(aNop_)       ;    /
   ds msb(aNop_)       ;    0
   ds msb(aNop_)       ;    1
   ds msb(aNop_)       ;    2
   ds msb(aNop_)       ;    3
   ds msb(aNop_)       ;    4
   ds msb(aNop_)       ;    5
   ds msb(aNop_)       ;    6
   ds msb(aNop_)       ;    7
   ds msb(aNop_)       ;    8
   ds msb(aNop_)       ;    9
   ds msb(aNop_)       ;    :  start defining a macro
   ds msb(aNop_)       ;    ;
   ds msb(aNop_)       ;    lsb( - 1)
   ds msb(aNop_)       ;    =
   ds msb(aNop_)       ;    >
   ds msb(aNop_)       ;    ?
   ds msb(cFetch_)     ;    @
   ds msb(aNop_)       ;    A
   ds msb(break_)      ;    B
   ds msb(nop_)        ;    C
   ds msb(depth_)      ;    D  ( -- val ) depth of data stack
   ds msb(emit_)       ;    E  ( val -- ) emits a char to output
   ds msb(aNop_)       ;    F
   ds msb(go_)         ;    G  ( -- ? ) execute mint definition
   ds msb(keyq_)       ;    H  ( verify if key hit )
   ds msb(inPort_)     ;    I  ( port -- val )
   ds msb(aNop_)       ;    J
   ds msb(key_)        ;    K  ( -- val )  read a char from input
   ds msb(aNop_)       ;    L
   ds msb(aNop_)       ;    M
   ds msb(newln_)      ;    N  ; prints a newline to output
   ds msb(outPort_)    ;    O  ( val port -- )
   ds msb(printStk_)   ;    P  ( -- ) non-destructively prints stack
   ds msb(aNop_)       ;    Q  quits from Mint REPL
   ds msb(rot_)        ;    R  ( a b c -- b c a )
   ds msb(aNop_)       ;    S
   ds msb(aNop_)       ;    T
   ds msb(r2s_)        ;    U  S( -- w ) R( w -- )
   ds msb(s2r_)        ;    V  S( w -- ) R( -- w )
   ds msb(aNop_)       ;    W   ; ( b -- ) if false, skip to end of loop
   ds msb(exec_)       ;    X
   ds msb(aNop_)       ;    Y
   ds msb(editDef_)    ;    Z
   ds msb(cArrDef_)    ;    [
   ds msb(comment_)    ;    \  comment text, skip reading until end of line
   ds msb(aNop_)       ;    ]
   ds msb(charCode_)   ;    ^
   ds msb(aNop_)       ;    _
   ds msb(aNop_)       ;    `
   ds msb(sysVar_)     ;    a  ; start of data stack *fixed
   ds msb(sysVar_)     ;    b  ; base16 flag
   ds msb(sysVar_)     ;    c  ; TIBPtr variable
   ds msb(sysVar_)     ;    d  ; vDefs variable
   ds msb(sysVar_)     ;    e  ;
   ds msb(sysVar_)     ;    f  ; start of return stack *fixed
   ds msb(sysVar_)     ;    g  ; next dispatcher
   ds msb(sysVar_)     ;    h  ; heap ptr variable
   ds msb(i_)          ;    i  ; returns index of current loop
   ds msb(j_)          ;    j  ; returns index of outer loop
   ds msb(sysVar_)     ;    k
   ds msb(sysVar_)     ;    l
   ds msb(sysVar_)     ;    m  ( a b -- c ) return the minimum value
   ds msb(sysVar_)     ;    n
   ds msb(sysVar_)     ;    o
   ds msb(sysVar_)     ;    p
   ds msb(sysVar_)     ;    q
   ds msb(sysVar_)     ;    r  ; return stack pointer
   ds msb(sysVar_)     ;    s  ; data stack pointer
   ds msb(sysVar_)     ;    t
   ds msb(sysVar_)     ;    u
   ds msb(sysVar_)     ;    v
   ds msb(sysVar_)     ;    w
   ds msb(sysVar_)     ;    x
   ds msb(sysVar_)     ;    y
   ds msb(sysVar_)     ;    z
   ds msb(group_)      ;    {
   ds msb(aNop_)       ;    |
   ds msb(endGroup_)   ;    }
   ds msb(aNop_)       ;    ~
   ds msb(aNop_)       ;    BS

; *********************************************************************
; Macros must be written in Mint and end with ;
; this code must not span pages
; *********************************************************************
macros:

;.include "MINT.macros.asm"

dw $DEAD

