# 6502.MINT

A still raw [Mint](https://github.com/monsonite/MINT) for 6502.

_this still a stub_

## Notes

_20/10/2023_

It is 6502, a 8-bit CPU doing 16-bit things, then better safe than sorry, tweak it if need more speed.

      a Z80, does 16-bit add (ADD HL, DE) in 12 cycles and use 1 byte  
      a 6502, does a 16-bit add it in 13 cycles and uses 9 bytes 

No plans for multi-task or multi-user or garbage collector or flush flash eeproms. 

### Code Design

   - this code is for ROM and uses less than 4096 bytes.
   - if change for RAM, caller must save A, X, Y and reserve at least 16 words at hardware stack 
   - a cell is 16-bit.
   - terminal input buffer is limited to 255 bytes, also any macro.  
   - extense use of Y indexed indirect addressing and absolute offsets by X
   - uses 16 bytes at page zero $F0 to $FF.
   - all input, output and  macros are stored on the heap in chunks of up to 255 bytes.
   - all MINT called functions ended with \_
   - all routines must end with: _jmp next_ or _jmp (vNext)_ or _jmp drop__ 
   
   
The code references was (still) not ordered into pages of "half address and mapped pages". 

The addresses of the routines were organized into lists of "low bytes and high bytes" for parallel query. 

It uses more 256 bytes than original Z80 layout, but allow almost 256 references per list.

### Stacks

   - stacks are 128 cells deep and round-robin, using indexed absolute address and grows backwards.
   - data stack and return stack are indexed by X, leaving index Y and hardware stack free.
   - all stack routines, load the index at start and save the index at end, if changed.

This leaves free SP, X and Y for general use. More in [Stacks](https://github.com/agsb/6502.MINT/blob/main/arch/6502/Stacks.md)
     
### MINT Changes

1. Depends on external BIOS for:
      - _hitc_, check if a key pressed,
      - _getc_, wait and receive a byte,
      - _putc_, wait and transmit a byte
      - _tick_, counts clock ticks, *not yet*

2. Expanded mint variables
      - _alt-a_, used for vS0, start of data stack, *hardcoded*
      - _alt-f_, used for vR0, start of return stack  *hardcoded*
      - _alt-g_, used for vNext, indirect dispatcher  
      - _alt-r_, return the return stack pointer
      - _alt-s_, return the data stack pointer

3. Expanded mint functions:
      - _alt-U_, classic Forth R> 
      - _alt-V_, classic Forth >R 
      - _alt-H_, verify if a key was hit 

      As is in code:
   
      - _*_, multiplication 16x16 leaves a reminder of product by 65536 and a quotient of product by 65536
      - _/_, division 16x16 leaves a reminder by divisor and a quotient by divisor   

4. A 6502 is a memory mapped I/O CPU, then InPort is mapped to cFetch and OutPort is mapped to cStore.
  
5. All variables and user macros are composed in groups,
      - Each group have 32 cells, 26 are accessed from 'a' to 'z', and last 6 cells below 'z'.
      - User macros extended for 5 groups  

6. Extra string functions, both ends at crlf or asciiz:
      - _gets\__, gets a line into a buffer, 
      - _puts\__, puts a line from a buffer,  

7. The parser is pos-incremented. No need decrement instruction pointer before goto parser. Easy check for end of buffer.

8. FALSE is _0x00_ and TRUE is non FALSE, maybe 0x01 to 0xFF.
      - Why? Easy Zero flag test, beq is FALSE, bne is TRUE.

9. Loops counts from 0 to 1 till 65535.
      - and begin tha flame wars...

