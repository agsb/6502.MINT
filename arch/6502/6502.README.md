# 6502.MINT

A still raw [Mint](https://github.com/monsonite/MINT) for 6502.

_this still a stub_

## Notes

_20/10/2023_

It is 6502, a 8-bit CPU doing 16-bit things, then better safe than sorry, tweak it if need more speed.

      a Z80, does 16-bit add (ADD HL, DE) in 12 cycles and use 1 byte  
      a 6502, does a 16-bit add it in 13 cycles and uses 9 bytes 

No plans for multi-task or multi-user or garbage collector or flush flash eeproms. 

### Code Design

   - this code is for ROM and uses less than 4096 bytes.
   - if change for RAM, caller must save A, X, Y and reserve at least 16 words at hardware stack 
   - a cell is 16-bit.
   - stacks are 128 cells deep and round-robin, using indexed absolute address and grows backwards.
   - data stack indexed by X and return stack indexed by Y, leaving hardware stack free.
   - terminal input buffer is limited to 255 bytes, also any macro.  
   - extense use of Y indexed indirect addressing and absolute offsets by X
   - uses 16 bytes at page zero $F0 to $FF.
   - allinput, output and  macros are stored on the heap in chunks of up to 255 bytes.
   - all MINT called functions ended with \_
   - all routines must end with: jmp _next_ or jmp _(vNext)_ or jmp _drop__ 
   - all stack routines, load the index at start and save the index at end, if changed. this leaves free SP, X and Y for general use.
   
The code references was not ordered into pages of "half address and mapped pages". 

The addresses of the routines were organized into lists of "low bytes and high bytes" for parallel query. 

It uses more 256 bytes than original layout, but allow almost 256 references per list.
     
### MINT Changes

1. Depends on external BIOS for:
      - _hitc_, check if a key pressed,
      - _getc_, wait and receive a byte,
      - _putc_, wait and transmit a byte
      - _tick_, counts clock ticks, *not yet*

2. Expanded mint variables
      - _alt-a_, used for vS0, start of data stack, *hardcoded*
      - _alt-f_, used for vR0, start of return stack  *hardcoded*
      - _alt-g_, used for vNext, indirect dispatcher  
      - _alt-r_, return the return stack pointer
      - _alt-s_, return the data stack pointer

3. Expanded mint functions:
      - _alt-U_, classic Forth R> 
      - _alt-V_, classic Forth >R 
      - _alt-H_, verify if a key was hit 

      As is in code:
   
      - _*_, multiplication 16x16 leaves a reminder of product by 65536 and a quotient of product by 65536
      - _/_, division 16x16 leaves a reminder by divisor and a quotient by divisor   

4. A 6502 is a memory mapped I/O CPU, then InPort is mapped to cFetch and OutPort is mapped to cStore.
  
5. All variables and user macros are composed in groups,
      - Each group have 32 cells, 26 are accessed from 'a' to 'z', and last 6 cells below 'z'.
      - User macros extended for 5 groups  

6. Extra string functions, both ends at crlf or asciiz:
      - _gets\__, gets a line into a buffer, 
      - _puts\__, puts a line from a buffer,  

7. The parser is pos-incremented. No need decrement instruction pointer before goto parser. Easy check for end of buffer.

8. FALSE is _0x00_ and TRUE is non FALSE, maybe 0x01 to 0xFF.
      - Why? Easy Zero flag test, beq is FALSE, bne is TRUE.

9. Loops counts from 0 to 1 till 65535.
      - and begin tha flame wars...

### The Stacks

There are four commom stacks implementations: 

1. Use of A,Y as top of data stack, hardware stack SP as data stack, and a indirect indexed access with Y for return stack.
2. Use SP for data stack and indirect indexed access with Y for return stack.
3. Use indirect indexed access with Y for data and return stack.
4. Use absolute indexed access with X for data and return stack.

#### use hardware stack
      - push {LDA?; PHA; LDA?; PHA;} ; 12 cycles
      - pull {PLA; STA?; PLA; STA?;} ; 12 cycles
      
Uses none of page zero and two bytes at hardware stack.

#### use indirect access
      prepare {LDY PZBYTE} 
      push {LDA?; STA(PZADDR),Y; INCY; LDA?; STA(PZADDR),Y; INCY;}
      pull {DECY; LDA(PZADDR),Y; STA?; DECY; LDA(PZADDR),Y; STA?}
      resume {STY PZBYTE}
      
Uses three bytes of page zero and none bytes at hardware stack.
      
#### use absolute indexed
     prepare: {LDY PZBYTE}
     push: {LDA?; STA [ADDR-2],Y; LDA?; STA[ADDR-1],Y; DECY; DECY;}
     pull: {LDA [ADDR+0],Y; STA?; LDA [ADDR+1],Y; STA?; INCY; INCY;}
     resume {STY PZBYTE}

Uses one byte of page zero, one address hardcoded inline and none bytes at hardware stack.

In 6502 code, to pass a byte between memory, need use LDA and STA (there are exotic alternatives, but all uses Accumulator)

Using absolute address indirect access for stacks. It provides the most fast overall implementation.

pros:
   offsets inline from a fixed reference
   direct memory access and exchange
   128 deep stack in round-robin

cons:
   can not change fixed reference

multitask and multiuser :
   indexed stacks are 128 words, Charles Moore says 22 is enough.
   Then could split 5 stacks for users or tasks, more than must exchange stacks values and include checks for stack limits.

  low memory
   -4  LSB
   -3  MSB
   -2  LSB
   -1  MSB
    0  LSB TOS
   +1  MSB
   +2  LSB NOS
   +3  MSB
   +4  LSB
   +5  MSB
 high memory

; to keep code safe do not using "fall throught".
; uses A, Y, X caller must saves.
; needs 2 levels of hardware stack
; uses 4 bytes in page zero as temporary
; uses 6 bytes in memory for internal use
;


    
