ca65 V2.19 - Git b688cfa0c
Main file   : 6502.MINT.s
Current file: 6502.MINT.s

000000r 1               ; vim: filetype=asm sw=8 ts=8 autoindent expandtab shiftwidth=8 et:
000000r 1               
000000r 1               ; *********************************************************************
000000r 1               ;
000000r 1               ;  MINT Minimal Interpreter
000000r 1               ;
000000r 1               ;  GNU GENERAL PUBLIC LICENSE              Version 3, 29 June 2007
000000r 1               ;
000000r 1               ;  see the LICENSE file in this repo for more information
000000r 1               ;
000000r 1               ;  original for the Z80, by Ken Boak, John Hardy and Craig Jones.
000000r 1               ;
000000r 1               ;  original for the 6502, by Alvaro G. S. Barcellos, 2023
000000r 1               ;
000000r 1               ;  agsb@ see the disclaimer file in this repo for more information.
000000r 1               ;
000000r 1               ;  agsb@ star(tm) date 10/10/2023
000000r 1               ;
000000r 1               ; *********************************************************************
000000r 1               ; this MINT is to be called after boot.
000000r 1               ;
000000r 1               ; ROM usable code, no relocable or self modify
000000r 1               ; memory depends on system host memory maps
000000r 1               ;
000000r 1               ; stacks grows backwards, push decrements, pull increments
000000r 1               ; using SP for return stack
000000r 1               ; usinf X for index on data stack
000000r 1               ;
000000r 1               ; reserve page two for terminal input buffer
000000r 1               ;
000000r 1               ;--------------------------------------------------------
000000r 1               ;
000000r 1               ;  ca65 assembler specifics
000000r 1               ;
000000r 1               ;--------------------------------------------------------
000000r 1               
000000r 1               ; identifiers
000000r 1               
000000r 1               .case +
000000r 1               
000000r 1               ; enable features
000000r 1               
000000r 1               .feature c_comments
000000r 1               
000000r 1               .feature string_escapes
000000r 1               
000000r 1               .feature org_per_seg
000000r 1               
000000r 1               .feature dollar_is_pc
000000r 1               
000000r 1               .feature pc_assignment
000000r 1               
000000r 1               ; enable 6502 mode
000000r 1               
000000r 1               .p02
000000r 1               
000000r 1               ;--------------------------------------------------------
000000r 1               ;
000000r 1               ;   constants, as must be.
000000r 1               ;
000000r 1               ;--------------------------------------------------------
000000r 1               
000000r 1                       TRUE  = 1
000000r 1                       FALSE = 0
000000r 1               
000000r 1               ; useful ascii
000000r 1               
000000r 1                       CAN = 24        ; ascii cancel
000000r 1                       CR  = 13        ; ascii carriage return
000000r 1                       LF  = 10        ; ascii line feed
000000r 1                       BS  = 9         ; ascii backspace
000000r 1                       ETX = 3         ; ascii end of text
000000r 1                       NUL = 0         ; ascii null
000000r 1                       BKX = 92        ; ascii back slash
000000r 1               
000000r 1               
000000r 1                       ; stack LIMIT words, backwards
000000r 1                       STKENDS = 256 - 64
000000r 1               
000000r 1                       ; size page
000000r 1                       PAGE = 256
000000r 1               
000000r 1                       ; group size, 32 x 16-bit words
000000r 1                       GRPSIZE = 64
000000r 1               
000000r 1                       ; groups for defs, could be more
000000r 1                       NUMGRPS = 5
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; for easy, Chuck does with 22 deep.
000000r 1               
000000r 1               ; bottom of data stack, reserve at least 26 words
000000r 1                       S0 = $00FF
000000r 1               
000000r 1               ; bottom of return stack, reserves at least 26 words
000000r 1                       R0 = $01FF
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; define emulator mode for basic IO
000000r 1               
000000r 1                       EMULATOR = 1
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               .segment "ZERO"
000000r 1               
000000r 1               ; offsets
000000r 1               
000000r 1               ; mint internals, depends on systems host
000000r 1               
000000r 1               ; reserved for variables
000000r 1               * = $00B0
0000B0  1               
0000B0  1               ; instruction pointer
0000B0  1  00 00        ipt:    .addr $0
0000B2  1               
0000B2  1               ; copycat nest counter
0000B2  1  00           nest: 	.byte $0
0000B3  1  00           vByteMode: .byte $0
0000B4  1               
0000B4  1               ; safes
0000B4  1  00           xpf:    .byte $0
0000B5  1  00           ypf:    .byte $0
0000B6  1               
0000B6  1               ; pseudo registers
0000B6  1  00 00        tos:    .word $0
0000B8  1  00 00        nos:    .word $0
0000BA  1  00 00        wrk:    .word $0
0000BC  1  00 00        tmp:    .word $0
0000BE  1               
0000BE  1               ; reserved for data stack
0000BE  1               * = $00C0
0000C0  1               
0000C0  1               ; data stack, top at $00FF
0000C0  1  00 00 00 00  stk:    .res 64, $0
0000C4  1  00 00 00 00  
0000C8  1  00 00 00 00  
000100  1               
000100  1               ;----------------------------------------------------------------------
000100  1               ;
000100  1               ; does not belongs to MINT
000100  1               ;
000100  1               ;.segment "VECTORS"
000100  1               ;
000100  1               ;.word init
000100  1               ;.word init
000100  1               ;.word init
000100  1               ;
000100  1               ;----------------------------------------------------------------------
000100  1               .segment "CODE"
000000r 1               
000000r 1               ; this is page two $200
000000r 1               ; terminal input buffer
000000r 1               * = $200
000200  1               tib:
000200  1  00 00 00 00          .res PAGE, $0
000204  1  00 00 00 00  
000208  1  00 00 00 00  
000300  1               
000300  1               ;----------------------------------------------------------------------
000300  1               ; aliases
000300  1               
000300  1               vS0      =  vsys + $00     ;    \a  ; start of data stack
000300  1               vBase16  =  vsys + $02     ;    \b  ; base16 flag
000300  1               vTIBPtr  =  vsys + $04     ;    \c  ; TIBPtr variable
000300  1               vDefs    =  vsys + $08     ;    \d  ; reference for group user functions
000300  1               vEdited  =  vsys + $0a     ;    \e  ;
000300  1               vR0      =  vsys + $0c     ;    \f  ; start of return stack
000300  1               vNext    =  vsys + $0e     ;    \g  ; next routine dispatcher
000300  1               vHeap    =  vsys + $10     ;    \h  ; heap ptr variable
000300  1               vIx      =  vsys + $12     ;    \i  ; inner loop counter
000300  1               vJx      =  vsys + $14     ;    \j  ; inner loop counter
000300  1               
000300  1               ;----------------------------------------------------------------------
000300  1               ; real code
000300  1               
000300  1               * = $300
000300  1               
000300  1               init:
000300  1               
000300  1               ;       wise
000300  1  78                   sei
000301  1  D8                   cld
000302  1  A2 FF                ldx #$FF
000304  1  9A                   txs
000305  1  58                   cli
000306  1               
000306  1               ;       normal init
000306  1               
000306  1  4C 06 0B             jmp main_
000309  1  4D 49 4E 54          .asciiz "MINT@6502"
00030D  1  40 36 35 30  
000311  1  32 00        
000313  1               
000313  1               ;----------------------------------------------------------------------
000313  1               .ifdef EMULATOR
000313  1               ;
000313  1               ; 25/10/2023, using lib6502, -M E000 -X 0000
000313  1               ;
000313  1               
000313  1               hitch:
000313  1               
000313  1               getch:
000313  1  AD 00 E0             lda $E000
000316  1               
000316  1                       ; test EOF
000316  1  C9 FF                cmp #$FF
000318  1  F0 04                beq byes
00031A  1               
00031A  1               putch:
00031A  1  8D 00 E0             sta $E000
00031D  1  60                   rts
00031E  1               
00031E  1               byes:
00031E  1                       ; exit of emulator
00031E  1  4C 00 00             jmp $0000
000321  1               
000321  1               
000321  1               ; ---------------------------------------------------------------------
000321  1               ; keyq does not work with emulator, using default key_
000321  1               keyq_:
000321  1               
000321  1               key_:
000321  1  20 13 03             jsr getch
000324  1  CA                   dex
000325  1  CA                   dex
000326  1  95 00                sta 0, x
000328  1  6C 7E 0D             jmp (vNext)
00032B  1               
00032B  1               emit_:
00032B  1  B5 00                lda 0, x
00032D  1  E8                   inx
00032E  1  E8                   inx
00032F  1  20 1A 03             jsr putch
000332  1  6C 7E 0D             jmp (vNext)
000335  1               
000335  1               .endif
000335  1               
000335  1               ; ---------------------------------------------------------------------
000335  1               ; Forth like functions
000335  1               
000335  1               ; ---------------------------------------------------------------------
000335  1               ;   data stack stuff
000335  1               
000335  1               spush:
000335  1               push_:
000335  1  CA                   dex
000336  1  CA                   dex
000337  1  A5 B7                lda tos + 1
000339  1  95 01                sta 1, x
00033B  1  A5 B6                lda tos + 0
00033D  1  95 00                sta 0, x
00033F  1  60                   rts
000340  1               
000340  1               spull:
000340  1               pull_:
000340  1  B5 00                lda 0, x
000342  1  85 B6                sta tos + 0
000344  1  B5 01                lda 1, x
000346  1  85 B7                sta tos + 1
000348  1  E8                   inx
000349  1  E8                   inx
00034A  1  60                   rts
00034B  1               
00034B  1               spull2:
00034B  1               pull2_:
00034B  1  20 40 03             jsr pull_
00034E  1  B5 00                lda 0, x
000350  1  85 B8                sta nos + 0
000352  1  B5 01                lda 1, x
000354  1  85 B9                sta nos + 1
000356  1  E8                   inx
000357  1  E8                   inx
000358  1  60                   rts
000359  1               
000359  1               ; ---------------------------------------------------------------------
000359  1               ; DROP
000359  1               drop_:
000359  1  E8                   inx
00035A  1  E8                   inx
00035B  1  6C 7E 0D             jmp (vNext)
00035E  1               ; DUP
00035E  1               dup_:
00035E  1  CA                   dex
00035F  1  CA                   dex
000360  1  B5 02                lda 2, x
000362  1  95 00                sta 0, x
000364  1  B5 03                lda 3, x
000366  1  95 01                sta 1, x
000368  1  6C 7E 0D             jmp (vNext)
00036B  1               
00036B  1               ; OVER
00036B  1               over_:
00036B  1  CA                   dex
00036C  1  CA                   dex
00036D  1  B5 04                lda 4, x
00036F  1  95 00                sta 0, x
000371  1  B5 05                lda 5, x
000373  1  95 01                sta 1, x
000375  1  6C 7E 0D             jmp (vNext)
000378  1               
000378  1               
000378  1               ; SWAP
000378  1               swap_:
000378  1  B5 02                lda 2, x
00037A  1  48                   pha
00037B  1  B5 03                lda 3, x
00037D  1  48                   pha
00037E  1               move_:
00037E  1  B5 00                lda 0, x
000380  1  95 02                sta 2, x
000382  1  B5 01                lda 1, x
000384  1  95 03                sta 3, x
000386  1  68                   pla
000387  1  95 01                sta 1, x
000389  1  68                   pla
00038A  1  95 00                sta 0, x
00038C  1  6C 7E 0D             jmp (vNext)
00038F  1               
00038F  1               ; ROT
00038F  1               rot_:
00038F  1  B5 04                lda 4, x
000391  1  48                   pha
000392  1  B5 05                lda 5, x
000394  1  48                   pha
000395  1  B5 02                lda 2, x
000397  1  95 04                sta 4, x
000399  1  B5 03                lda 3, x
00039B  1  95 05                sta 5, x
00039D  1  4C 7E 03             jmp move_
0003A0  1               
0003A0  1               ; AND
0003A0  1               and_:
0003A0  1  B5 00                lda  0, x
0003A2  1  35 02                and  2, x
0003A4  1  95 02                sta  2, x
0003A6  1  B5 01                lda  1, x
0003A8  1  35 03                and  3, x
0003AA  1  4C E0 03             jmp nsta3_
0003AD  1               
0003AD  1               ; OR
0003AD  1               or_:
0003AD  1  B5 00                lda  0, x
0003AF  1  15 02                ora  2, x
0003B1  1  95 02                sta  2, x
0003B3  1  B5 01                lda  1, x
0003B5  1  15 03                ora  3, x
0003B7  1  4C E0 03             jmp nsta3_
0003BA  1               
0003BA  1               ; XOR
0003BA  1               xor_:
0003BA  1  B5 00                lda  0, x
0003BC  1  55 02                eor  2, x
0003BE  1  95 02                sta  2, x
0003C0  1  B5 01                lda  1, x
0003C2  1  55 03                eor  3, x
0003C4  1  4C E0 03             jmp nsta3_
0003C7  1               
0003C7  1               ; ADD
0003C7  1               add_:
0003C7  1  18                   clc
0003C8  1  B5 02                lda  2, x
0003CA  1  75 00                adc  0, x
0003CC  1  95 02                sta  2, x
0003CE  1  B5 03                lda  3, x
0003D0  1  75 01                adc  1, x
0003D2  1  4C E0 03             jmp nsta3_
0003D5  1               
0003D5  1               ; SUB
0003D5  1               sub_:
0003D5  1  38                   sec
0003D6  1  B5 02                lda  2, x
0003D8  1  F5 00                sbc  0, x
0003DA  1  95 02                sta  2, x
0003DC  1  B5 03                lda  3, x
0003DE  1  F5 01                sbc  1, x
0003E0  1               
0003E0  1               nsta3_:
0003E0  1  95 03                sta  3, x
0003E2  1  4C 59 03             jmp drop_
0003E5  1               
0003E5  1               ; NEGATE
0003E5  1               neg_:
0003E5  1  A9 00                lda #$00
0003E7  1  2C                   .byte $2c   ; mask next two bytes, nice trick !
0003E8  1               
0003E8  1               ; INVERT
0003E8  1               inv_:
0003E8  1  A9 FF                lda #$FF
0003EA  1               cpt_:
0003EA  1  38                   sec
0003EB  1  48                   pha
0003EC  1  F5 00                sbc  0, x
0003EE  1  95 00                sta  0, x
0003F0  1  38                   sec
0003F1  1  68                   pla
0003F2  1  F5 01                sbc  1, x
0003F4  1  95 01                sta  1, x
0003F6  1  6C 7E 0D             jmp (vNext)
0003F9  1               
0003F9  1               ; COMPARES
0003F9  1               cmp_:
0003F9  1  38                   sec
0003FA  1  B5 00                lda  0, x
0003FC  1  F5 02                sbc  2, x
0003FE  1  B5 01                lda  1, x
000400  1  F5 03                sbc  3, x
000402  1  60                   rts
000403  1               
000403  1               ; EQ
000403  1               eq_:
000403  1  20 F9 03             jsr cmp_
000406  1  F0 11                beq true2_
000408  1  D0 0C                bne false2_
00040A  1               
00040A  1               ; LESS THAN
00040A  1               lt_:
00040A  1  20 F9 03             jsr cmp_
00040D  1  30 0A                bmi true2_
00040F  1  10 05                bpl false2_
000411  1               
000411  1               ; GREATER THAN
000411  1               gt_:
000411  1  20 F9 03             jsr cmp_
000414  1  10 03                bpl true2_
000416  1               
000416  1               ; FALSE
000416  1               false2_:
000416  1  A9 00                lda #FALSE
000418  1  2C                   .byte $2c   ; mask next two bytes, nice trick !
000419  1               
000419  1               ; TRUE
000419  1               true2_:
000419  1  A9 01                lda #TRUE
00041B  1               
00041B  1               ; SAMES
00041B  1               same2_:
00041B  1  95 02                sta  2, x
00041D  1  95 03                sta  3, x
00041F  1  4C 59 03             jmp drop_
000422  1               
000422  1               ; SHIFT LEFT
000422  1               shl_:
000422  1  16 00                asl  0, x
000424  1  36 01                rol  1, x
000426  1  6C 7E 0D             jmp (vNext)
000429  1               
000429  1               ; SHIFT RIGHT
000429  1               shr_:
000429  1  56 00                lsr  0, x
00042B  1  76 01                ror  1, x
00042D  1  6C 7E 0D             jmp (vNext)
000430  1               
000430  1               ; store byte
000430  1               cto_:
000430  1  20 4B 03             jsr pull2_
000433  1  A0 00                ldy #0
000435  1  A5 B8                lda nos + 0
000437  1  91 B6                sta (tos), y
000439  1  60                   rts
00043A  1               
00043A  1               ; store word
00043A  1               to_:
00043A  1  20 30 04             jsr cto_
00043D  1  C8                   iny
00043E  1  A5 B9                lda nos + 1
000440  1  91 B6                sta (tos), y
000442  1  60                   rts
000443  1               
000443  1               ; byte store
000443  1               cstore_:
000443  1  20 30 04             jsr cto_
000446  1                       ; rts
000446  1  6C 7E 0D             jmp (vNext)
000449  1               
000449  1               ; word store
000449  1               store_:
000449  1  20 3A 04             jsr to_
00044C  1                       ; rts
00044C  1  6C 7E 0D             jmp (vNext)
00044F  1               
00044F  1               ; fetch byte
00044F  1               cat_:
00044F  1  B5 00                lda  0, x
000451  1  85 B6                sta tos + 0
000453  1  B5 01                lda  1, x
000455  1  85 B7                sta tos + 1
000457  1  A0 00                ldy #0
000459  1  B1 B6                lda (tos), y
00045B  1  95 00                sta  0, x
00045D  1  60                   rts
00045E  1               
00045E  1               ; fetch word
00045E  1               at_:
00045E  1  20 4F 04             jsr cat_
000461  1  C8                   iny
000462  1  B1 B6                lda (tos), y
000464  1  95 01                sta  1, x
000466  1  60                   rts
000467  1               
000467  1               ; fetch byte
000467  1               cfetch_:
000467  1  20 4F 04             jsr cat_
00046A  1  6C 7E 0D             jmp (vNext)
00046D  1               
00046D  1               ; fetch word
00046D  1               fetch_:
00046D  1  20 5E 04             jsr at_
000470  1  6C 7E 0D             jmp (vNext)
000473  1               
000473  1               ; increase a word at stack
000473  1               incr_:
000473  1  F6 00                inc  0, x
000475  1  D0 02                bne @ends
000477  1  F6 01                inc  1, x
000479  1               @ends:
000479  1  6C 7E 0D             jmp (vNext)
00047C  1               
00047C  1               ; decrease a word at stack
00047C  1               decr_:
00047C  1  B5 00                lda  0, x
00047E  1  D0 02                bne @ends
000480  1  D6 01                dec  1, x
000482  1               @ends:
000482  1  D6 00                dec  0, x
000484  1  6C 7E 0D             jmp (vNext)
000487  1               
000487  1               ; absolute jump to code
000487  1               ; on 6502 use rti, the rts increase the return address
000487  1               goto_:
000487  1  B5 00                lda  0, x
000489  1  48                   pha
00048A  1  B5 01                lda  1, x
00048C  1  48                   pha
00048D  1  08                   php
00048E  1  E8                   inx
00048F  1  E8                   inx
000490  1  40                   rti
000491  1               
000491  1               ; +! ADD STORE
000491  1               addto_:
000491  1  20 4B 03             jsr pull2_
000494  1  A0 00                ldy #0
000496  1  18                   clc
000497  1  B1 B6                lda (tos), y
000499  1  65 B8                adc nos + 0
00049B  1  91 B6                sta (tos), y
00049D  1  C8                   iny
00049E  1  B1 B6                lda (tos), y
0004A0  1  65 B9                adc nos + 1
0004A2  1  91 B6                sta (tos), y
0004A4  1                       ; rts
0004A4  1  6C 7E 0D     	jmp (vNext)
0004A7  1               
0004A7  1               ; -! SUB STORE
0004A7  1               subto_:
0004A7  1  20 4B 03             jsr pull2_
0004AA  1  A0 00                ldy #0
0004AC  1  38                   sec
0004AD  1  B1 B6                lda (tos), y
0004AF  1  E5 B8                sbc nos + 0
0004B1  1  91 B6                sta (tos), y
0004B3  1  C8                   iny
0004B4  1  B1 B6                lda (tos), y
0004B6  1  E5 B9                sbc nos + 1
0004B8  1  91 B6                sta (tos), y
0004BA  1                       ; rts
0004BA  1  6C 7E 0D     	jmp (vNext)
0004BD  1               
0004BD  1               ;----------------------------------------------------------------------
0004BD  1               ;   return stack stuff
0004BD  1               
0004BD  1               ; usual >R
0004BD  1               s2r_:
0004BD  1               rpush_:
0004BD  1  B5 00                lda 0, x
0004BF  1  48                   pha
0004C0  1  B5 01                lda 1, x
0004C2  1  48                   pha
0004C3  1  E8                   inx
0004C4  1  E8                   inx
0004C5  1  6C 7E 0D             jmp (vNext)
0004C8  1               
0004C8  1               ; usual R>
0004C8  1               r2s_:
0004C8  1               rpull_:
0004C8  1  CA                   dex
0004C9  1  CA                   dex
0004CA  1               putw_:
0004CA  1  68                   pla
0004CB  1  95 01                sta 1, x
0004CD  1  68                   pla
0004CE  1  95 00                sta 0, x
0004D0  1  6C 7E 0D             jmp (vNext)
0004D3  1               
0004D3  1               ;----------------------------------------------------------------------
0004D3  1               
0004D3  1               ; usual R@
0004D3  1               rshow_:
0004D3  1  CA                   dex
0004D4  1  CA                   dex
0004D5  1  68                   pla
0004D6  1  95 01                sta 1, x
0004D8  1  68                   pla
0004D9  1  95 00                sta 0, x
0004DB  1  48                   pha
0004DC  1  B5 01                lda 1, x
0004DE  1  48                   pha
0004DF  1  6C 7E 0D             jmp (vNext)
0004E2  1               
0004E2  1               ; SP@
0004E2  1               dat2t_:
0004E2  1  8A                   txa
0004E3  1  48                   pha
0004E4  1  A9 00                lda #0
0004E6  1  48                   pha
0004E7  1  F0 DF                beq rpull_
0004E9  1               ; RP@
0004E9  1               ret2t_:
0004E9  1  86 B4                stx xpf
0004EB  1  BA                   tsx
0004EC  1  8A                   txa
0004ED  1  A6 B4                ldx xpf
0004EF  1  48                   pha
0004F0  1  A9 01                lda #1
0004F2  1  48                   pha
0004F3  1  D0 D3                bne rpull_
0004F5  1               
0004F5  1               ; SP!
0004F5  1               t2dat_:
0004F5  1  A9 FF                lda #$FF
0004F7  1  AA                   tax
0004F8  1  6C 7E 0D             jmp (vNext)
0004FB  1               
0004FB  1               ; RP!
0004FB  1               t2ret_:
0004FB  1  A9 FF                lda #$FF
0004FD  1  86 B4                stx xpf
0004FF  1  AA                   tax
000500  1  BA                   tsx
000501  1  A6 B4                ldx xpf
000503  1  6C 7E 0D             jmp (vNext)
000506  1               
000506  1               ;----------------------------------------------------------------------
000506  1               ; need review
000506  1               ;----------------------------------------------------------------------
000506  1               ; prepare for mult or divd
000506  1               opin:
000506  1                       ; pseudo tos
000506  1  B5 00                lda  0, x
000508  1  85 BA                sta wrk + 0
00050A  1  B5 01                lda  1, x
00050C  1  85 BB                sta wrk + 1
00050E  1                       ; pseudo nos
00050E  1  B5 02                lda  2, x
000510  1  85 BC                sta tmp + 0
000512  1  B5 03                lda  3, x
000514  1  85 BD                sta tmp + 1
000516  1                       ; clear results
000516  1  A9 00                lda #0
000518  1  85 B6                sta tos + 0
00051A  1  85 B7                sta tos + 1
00051C  1  85 B8                sta nos + 0
00051E  1  85 B9                sta nos + 1
000520  1                       ; countdown
000520  1  A0 10                ldy #16
000522  1  60                   rts
000523  1               
000523  1               ;----------------------------------------------------------------------
000523  1               ; resume from mult or divd
000523  1               opout:
000523  1                       ; copy results
000523  1  A5 B8                lda nos + 0
000525  1  95 00                sta  0, x
000527  1  A5 B9                lda nos + 1
000529  1  95 01                sta  1, x
00052B  1  A5 B6                lda tos + 0
00052D  1  95 02                sta  2, x
00052F  1  A5 B7                lda tos + 1
000531  1  95 03                sta  3, x
000533  1                       ; rts
000533  1  6C 7E 0D             jmp (vNext)
000536  1               
000536  1               ;----------------------------------------------------------------------
000536  1               ; Divide the top 2 cell of the stack
000536  1               ; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
000536  1               ; dividend divisor -- result remainder
000536  1               ; ( tmp wrk -- nos tos )
000536  1               div_:
000536  1  20 06 05             jsr opin
000539  1               @loop:
000539  1  06 BC                asl tmp + 0
00053B  1  26 BD                rol tmp + 1
00053D  1  26 B6                rol tos + 0
00053F  1  26 B7                rol tos + 1
000541  1  38                   sec
000542  1  A5 B6                lda tos + 0
000544  1  E5 BA                sbc wrk + 0
000546  1  AA                   tax
000547  1  A5 B7                lda tos + 1
000549  1  E5 BB                sbc wrk + 1
00054B  1  90 06                bcc @skip
00054D  1  85 B7                sta tos + 1
00054F  1  86 B6                stx tos + 0
000551  1  E6 BC                inc tmp + 0
000553  1               @skip:
000553  1                       ; countdown
000553  1  88                   dey
000554  1  D0 E3                bne @loop
000556  1                       ; results
000556  1  A5 BC                lda tmp + 0
000558  1  85 B8                sta nos + 0
00055A  1  A5 BD                lda tmp + 1
00055C  1  85 B9                sta nos + 1
00055E  1                       ; ends
00055E  1  4C 23 05             jmp opout
000561  1               
000561  1               ;----------------------------------------------------------------------
000561  1               ; 16-bit multiply 16x16, 32 result
000561  1               ; http://codebase64.org/doku.php?id=base:16bit_multiplication_32-bit_product
000561  1               ; ( multiplicand multiplier -- resultMSW resultLSW )
000561  1               ; ( tmp wrk -- nos tos )
000561  1               mul_:
000561  1  20 06 05             jsr opin
000564  1               @shift_r:
000564  1                       ; divide by 2
000564  1  46 BB                lsr wrk + 1
000566  1  66 BA                ror wrk + 0
000568  1  90 0B                bcc @rotate_r
00056A  1                       ; add multiplicand to upper half product
00056A  1  AA                   tax
00056B  1  18                   clc
00056C  1  A5 BC                lda tmp + 0
00056E  1  65 B6                adc tos + 0
000570  1  85 B6                sta tos + 0
000572  1  8A                   txa
000573  1  65 BD                adc tmp + 1
000575  1               @rotate_r:
000575  1                       ; rotate partial product upper to low
000575  1  6A                   ror
000576  1  66 B7                ror tos + 1
000578  1  66 B9                ror nos + 1
00057A  1  66 B8                ror nos + 0
00057C  1                       ; countdown
00057C  1  88                   dey
00057D  1  D0 E5                bne @shift_r
00057F  1  85 B6                sta tos + 0
000581  1                       ; ends
000581  1  4C 23 05             jmp opout
000584  1               
000584  1               ;----------------------------------------------------------------------
000584  1               ;
000584  1               ; some extras
000584  1               ;
000584  1               ; vide eorBookV1.0.1
000584  1               
000584  1               ; set overflow bit
000584  1               setov_:
000584  1  2C 87 05             bit @ends
000587  1               @ends:
000587  1  60                   rts
000588  1               
000588  1               ; where I am
000588  1               here_:
000588  1  20 8B 05             jsr @pops
00058B  1               @pops:
00058B  1  68                   pla
00058C  1  A8                   tay
00058D  1  68                   pla
00058E  1  AA                   tax
00058F  1  60                   rts
000590  1               
000590  1               ; Z flag is zero in NMOS6502
000590  1               nmos_:
000590  1  F8                   sed
000591  1  18                   clc
000592  1  A9 99                lda #$99
000594  1  69 01                adc #$01
000596  1  D8                   cld
000597  1  60                   rts
000598  1               
000598  1               ;----------------------------------------------------------------------
000598  1               ;   MINT
000598  1               ;----------------------------------------------------------------------
000598  1               ; NOOP
000598  1               aNop_:
000598  1               nop_:
000598  1                       ; next
000598  1  4C 96 08             jmp next
00059B  1               
00059B  1               ;----------------------------------------------------------------------
00059B  1               ; add a byte offset to instruction pointer
00059B  1               add2ps:
00059B  1               ; update ip
00059B  1  18                   clc
00059C  1  65 B0                adc ipt + 0
00059E  1  85 B0                sta ipt + 0
0005A0  1  90 02                bcc @ends
0005A2  1  E6 B1                inc ipt + 1
0005A4  1               @ends:
0005A4  1                       ; next
0005A4  1  6C 7E 0D             jmp (vNext)
0005A7  1               
0005A7  1               ;----------------------------------------------------------------------
0005A7  1               seekps:
0005A7  1  A0 00                ldy #0
0005A9  1  B1 B0                lda (ipt), y
0005AB  1  E6 B0                inc ipt + 0
0005AD  1  D0 02                bne @ends
0005AF  1  E6 B1                inc ipt + 1
0005B1  1               @ends:
0005B1  1  60                   rts
0005B2  1               
0005B2  1               ;----------------------------------------------------------------------
0005B2  1               heap2nos:
0005B2  1  AD 80 0D             lda vHeap + 0
0005B5  1  85 B8                sta nos + 0
0005B7  1  AD 81 0D             lda vHeap + 1
0005BA  1  85 B9                sta nos + 1
0005BC  1  60                   rts
0005BD  1               
0005BD  1               ;----------------------------------------------------------------------
0005BD  1               add2heap:
0005BD  1  18                   clc
0005BE  1  6D 80 0D             adc vHeap + 0
0005C1  1  8D 80 0D             sta vHeap + 0
0005C4  1  90 03                bcc @ends
0005C6  1  EE 81 0D             inc vHeap + 1
0005C9  1               @ends:
0005C9  1  60                   rts
0005CA  1               
0005CA  1               ;----------------------------------------------------------------------
0005CA  1               tib2tos:
0005CA  1  A9 00                lda #<tib
0005CC  1  85 B6                sta tos + 0
0005CE  1  A9 02                lda #>tib
0005D0  1  85 B7                sta tos + 1
0005D2  1  60                   rts
0005D3  1               
0005D3  1               ;----------------------------------------------------------------------
0005D3  1               add2tos:
0005D3  1  18                   clc
0005D4  1  65 B6                adc tos + 0
0005D6  1  85 B6                sta tos + 0
0005D8  1  90 02                bcc @ends
0005DA  1  E6 B7                inc tos + 1
0005DC  1               @ends:
0005DC  1  60                   rts
0005DD  1               
0005DD  1               ;----------------------------------------------------------------------
0005DD  1               inc2tos:
0005DD  1  E6 B6                inc tos + 0
0005DF  1  90 02                bcc @ends
0005E1  1  E6 B7                inc tos + 1
0005E3  1               @ends:
0005E3  1  60                   rts
0005E4  1               
0005E4  1               ;----------------------------------------------------------------------
0005E4  1               ; sub
0005E4  1               subn2t:
0005E4  1  38                   sec
0005E5  1  A5 B6                lda tos + 0
0005E7  1  E5 B8                sbc nos + 0
0005E9  1  85 B6                sta tos + 0
0005EB  1  A5 B7                lda tos + 1
0005ED  1  E5 B9                sbc nos + 1
0005EF  1  85 B7                sta tos + 1
0005F1  1  60                   rts
0005F2  1               
0005F2  1               ;----------------------------------------------------------------------
0005F2  1               ; add
0005F2  1               addn2t:
0005F2  1  18                   clc
0005F3  1  A5 B6                lda tos + 0
0005F5  1  65 B8                adc nos + 0
0005F7  1  85 B6                sta tos + 0
0005F9  1  A5 B7                lda tos + 1
0005FB  1  65 B9                adc nos + 1
0005FD  1  85 B7                sta tos + 1
0005FF  1  60                   rts
000600  1               
000600  1               ;----------------------------------------------------------------------
000600  1               ; add 2x
000600  1               addt2t:
000600  1  06 B6                asl tos + 0
000602  1  26 B7                rol tos + 1
000604  1  60                   rts
000605  1               
000605  1               ;----------------------------------------------------------------------
000605  1               ; $00 to $1F, reserved for macros
000605  1               ; macros could not call macros.
000605  1               macro:
000605  1  8C 74 0D             sty vTIBPtr ; maybe spush
000608  1  A8                   tay
000609  1  B9 70 0C             lda ctlcodeslo, y
00060C  1  85 B6                sta tos + 0
00060E  1  B9 F0 0C             lda ctlcodeshi, y
000611  1  85 B7                sta tos + 1
000613  1  20 35 03             jsr spush
000616  1                       ;
000616  1  20 B8 08             jsr enter
000619  1  5C 47 00             .asciiz "\\G"
00061C  1  AC 74 0D             ldy vTIBPtr ; maybe spull
00061F  1  4C 2F 06             jmp interpret2
000622  1               
000622  1               ;----------------------------------------------------------------------
000622  1               interpret:
000622  1  20 B8 08             jsr enter
000625  1  5C 4E 60 3E          .asciiz "\\N`> `"
000629  1  20 60 00     
00062C  1                       ; fall thru
00062C  1               
00062C  1               ; used by TESTs
00062C  1               interpret1:
00062C  1  A9 00                lda #0
00062E  1  A8                   tay
00062F  1               
00062F  1               interpret2:
00062F  1  8C 74 0D             sty vTIBPtr
000632  1  A9 00                lda #0
000634  1  85 B2                sta nest
000636  1  A8                   tay
000637  1  F0 09                beq @isnest
000639  1               
000639  1               ; calc nesting (a macro might have changed it)
000639  1               @loop:
000639  1  B9 00 02             lda tib, y
00063C  1  F0 09                beq waitchar
00063E  1  20 9A 06             jsr nesting            ; update nesting value
000641  1  C8                   iny
000642  1               @isnest:
000642  1  CC 74 0D             cpy vTIBPtr
000645  1  D0 F2                bne @loop
000647  1                       ; fall thru
000647  1               
000647  1               ;----------------------------------------------------------------------
000647  1               ; loop around waiting for character
000647  1               ; get a line into tib
000647  1               waitchar:
000647  1  20 CA 05             jsr tib2tos
00064A  1  20 35 03             jsr spush
00064D  1                       ; fall thru
00064D  1               
00064D  1               ;----------------------------------------------------------------------
00064D  1               ; get a line into buffer pointer by TOS
00064D  1               gets_:
00064D  1                       ; already
00064D  1  A0 00                ldy #0
00064F  1  20 40 03             jsr spull
000652  1               
000652  1               @loop:
000652  1                       ; limit 254
000652  1  C0 FE                cpy #$FE
000654  1  F0 2D                beq @endstr
000656  1               
000656  1  20 13 03             jsr getch
000659  1               
000659  1                       ; ge space ?
000659  1  C9 20                cmp #32
00065B  1  B0 0F                bcs @ischar
00065D  1                       ; is it ia NUL ?
00065D  1  C9 00                cmp #$0
00065F  1  F0 22                beq @endstr
000661  1                       ; windows CRLF, linux CR, Mac LF
000661  1  C9 0D                cmp #CR                 ; carriage return ?
000663  1  F0 10                beq @iscrlf
000665  1  C9 0A                cmp #LF                 ; line feed ?
000667  1  F0 0C                beq @iscrlf
000669  1               
000669  1               @ismacro:
000669  1                       ; $00 to $1F
000669  1                       ; y is the position in tib
000669  1                       ; a is the code
000669  1  4C 05 06             jmp macro
00066C  1               
00066C  1               @ischar:
00066C  1  20 93 06             jsr @toTib
00066F  1                       ; nest ?
00066F  1  20 9A 06             jsr nesting
000672  1                       ; wait for next character
000672  1  18                   clc
000673  1  90 DD                bcc @loop
000675  1               
000675  1               @iscrlf:
000675  1                       ; just for easy
000675  1  A9 0D                lda #CR
000677  1  20 93 06             jsr @toTib
00067A  1  A9 0A                lda #LF
00067C  1  20 93 06             jsr @toTib
00067F  1                       ; pending nest ?
00067F  1  A5 B2                lda nest
000681  1  D0 CF                bne @loop
000683  1               
000683  1               ; mark end with etx,
000683  1               @endstr:
000683  1                       ; mark ETX
000683  1  A9 03                lda #ETX
000685  1  91 B6                sta (tos), y
000687  1  C8                   iny
000688  1               
000688  1                       ; update instruction pointer
000688  1  A5 B6                lda tos + 0
00068A  1  85 B0                sta ipt + 0
00068C  1  A5 B7                lda tos + 1
00068E  1  85 B1                sta ipt + 1
000690  1               
000690  1                       ; next
000690  1  4C 96 08             jmp next
000693  1               
000693  1               ; maximum 254 chars
000693  1               @toTib:
000693  1                       ; echo
000693  1  20 1A 03             jsr putch
000696  1                       ; store
000696  1  91 B6                sta (tos), y
000698  1  C8                   iny
000699  1  60                   rts
00069A  1               
00069A  1               ;----------------------------------------------------------------------
00069A  1               ; nesting deep
00069A  1               nesting:
00069A  1  C9 60                cmp #'`'
00069C  1  D0 07                bne @nests
00069E  1                       ; toggle bit 7
00069E  1  A9 80                lda #$80
0006A0  1  45 B2                eor nest
0006A2  1  85 B2                sta nest
0006A4  1  60                   rts
0006A5  1               @nests:
0006A5  1  24 B2                bit nest
0006A7  1  30 18                bmi @nonest
0006A9  1  C9 3A                cmp #':'
0006AB  1  F0 15                beq @nestinc
0006AD  1  C9 5B                cmp #'['
0006AF  1  F0 11                beq @nestinc
0006B1  1  C9 28                cmp #'('
0006B3  1  F0 0D                beq @nestinc
0006B5  1  C9 3B                cmp #';'
0006B7  1  F0 0C                beq @nestdec
0006B9  1  C9 5D                cmp #']'
0006BB  1  F0 08                beq @nestdec
0006BD  1  C9 29                cmp #')'
0006BF  1  F0 04                beq @nestdec
0006C1  1               @nonest:
0006C1  1  60                   rts
0006C2  1               @nestinc:
0006C2  1  E6 B2                inc nest
0006C4  1  60                   rts
0006C5  1               @nestdec:
0006C5  1  C6 B2                dec nest
0006C7  1  60                   rts
0006C8  1               
0006C8  1               ;----------------------------------------------------------------------
0006C8  1               ; prints a asciiz, refered by hardware stack
0006C8  1               printStr:
0006C8  1                       ; reference
0006C8  1  68                   pla
0006C9  1  85 B6                sta tos + 0
0006CB  1  68                   pla
0006CC  1  85 B7                sta tos + 1
0006CE  1               
0006CE  1  20 DD 05             jsr inc2tos
0006D1  1               
0006D1  1                       ; asciiz
0006D1  1  A2 00                ldx #NUL
0006D3  1  20 F5 06             jsr putstr
0006D6  1               
0006D6  1                       ; offset
0006D6  1  20 D3 05             jsr add2tos
0006D9  1  A5 B7                lda tos + 1
0006DB  1  48                   pha
0006DC  1  A5 B6                lda tos + 0
0006DE  1  48                   pha
0006DF  1  60                   rts
0006E0  1               
0006E0  1               ;----------------------------------------------------------------------
0006E0  1               ; puts a string, ends on `
0006E0  1               str_:
0006E0  1  A5 B0                lda ipt + 0
0006E2  1  85 B6                sta tos + 0
0006E4  1  A5 B1                lda ipt + 1
0006E6  1  85 B7                sta tos + 1
0006E8  1  A2 01                ldx #TRUE
0006EA  1  20 F5 06             jsr putstr
0006ED  1                       ; next
0006ED  1  6C 7E 0D             jmp (vNext)
0006F0  1               
0006F0  1               ;----------------------------------------------------------------------
0006F0  1               ; puts a string, asciiz
0006F0  1               puts_:
0006F0  1  A2 00                ldx #NUL
0006F2  1  20 40 03             jsr spull
0006F5  1                       ; fall thru
0006F5  1               
0006F5  1               ;----------------------------------------------------------------------
0006F5  1               ; prints a asciiz
0006F5  1               putstr:
0006F5  1  A0 00                ldy #NUL
0006F7  1               @loop:
0006F7  1  B1 B6                lda (tos), y
0006F9  1  F0 0E                beq @ends   ; limit NUL
0006FB  1  E0 00                cpx #NUL
0006FD  1  F0 04                beq @cont
0006FF  1  C9 60                cmp #'`'        ; ` is the string terminator
000701  1  F0 06                beq @ends
000703  1               @cont:
000703  1  20 1A 03             jsr putch
000706  1  C8                   iny
000707  1  D0 EE                bne @loop   ; limit 256
000709  1               @ends:
000709  1  98                   tya
00070A  1  60                   rts
00070B  1               
00070B  1               ;----------------------------------------------------------------------
00070B  1               ; prints number in tos to decimal ASCII
00070B  1               ; ps. putchar ends with rts
00070B  1               printdec:
00070B  1  A9 10                lda #<10000
00070D  1  85 B8                sta nos + 0
00070F  1  A9 27                lda #>10000
000711  1  85 B9                sta nos + 1
000713  1  20 34 07             jsr @nums
000716  1  A9 E8                lda #<1000
000718  1  85 B8                sta nos + 0
00071A  1  A9 03                lda #>1000
00071C  1  85 B9                sta nos + 1
00071E  1  20 34 07             jsr @nums
000721  1  A9 64                lda #<100
000723  1  85 B8                sta nos + 0
000725  1  A9 00                lda #>100
000727  1  85 B9                sta nos + 1
000729  1  20 34 07             jsr @nums
00072C  1  A9 0A                lda #<10
00072E  1  85 B8                sta nos + 0
000730  1  A9 00                lda #>10
000732  1  85 B9                sta nos + 1
000734  1               @nums:
000734  1  A0 2F                ldy #'0'-1
000736  1               @loop:
000736  1                       ; subtract
000736  1  C8                   iny
000737  1  20 E4 05             jsr subn2t
00073A  1  B0 FA                bcs @loop
00073C  1                       ; restore
00073C  1  20 F2 05             jsr addn2t
00073F  1  98                   tya
000740  1  4C 1A 03             jmp putch
000743  1               
000743  1               ;----------------------------------------------------------------------
000743  1               ; prints number in tos to hexadecimal ASCII
000743  1               printhex:
000743  1  A5 B7                lda tos + 1
000745  1  20 4E 07             jsr printhex8
000748  1  A5 B6                lda tos + 0
00074A  1  20 4E 07             jsr printhex8
00074D  1  60                   rts
00074E  1               
00074E  1               ;----------------------------------------------------------------------
00074E  1               ; print a 8-bit HEX
00074E  1               printhex8:
00074E  1  AA                   tax
00074F  1  4A                   lsr
000750  1  6A                   ror
000751  1  6A                   ror
000752  1  6A                   ror
000753  1  20 57 07             jsr @conv
000756  1  8A                   txa
000757  1               @conv:
000757  1  29 0F                and #$0F
000759  1  18                   clc
00075A  1  09 30                ora #$30
00075C  1  C9 3A                cmp #$3A
00075E  1  90 02                bcc @ends
000760  1  69 06                adc #$06
000762  1               @ends:
000762  1  4C 1A 03             jmp putch
000765  1               
000765  1               ;----------------------------------------------------------------------
000765  1               nul2tos:
000765  1  A9 00                lda #NUL
000767  1  85 B6                sta tos + 0
000769  1  85 B7                sta tos + 1
00076B  1  60                   rts
00076C  1               
00076C  1               ;---------------------------------------------------------------------
00076C  1               isdec:
00076C  1  C9 30                cmp #'0' + 0
00076E  1  90 09                bcc nak
000770  1  C9 3A                cmp #'9' + 1
000772  1  B0 05                bcs nak
000774  1  38                   sec
000775  1  E9 30                sbc #'0'
000777  1               ack:
000777  1  18                   clc
000778  1  60                   rts
000779  1               nak:
000779  1  38                   sec
00077A  1  60                   rts
00077B  1               
00077B  1               ;---------------------------------------------------------------------
00077B  1               ishex:
00077B  1                       ; to upper, clear bit-6
00077B  1  29 DF                and #%11011111
00077D  1  C5 41                cmp 'A'
00077F  1  90 F8                bcc nak
000781  1  C5 47                cmp 'F' + 1
000783  1  B0 F4                bcs nak
000785  1  38                   sec
000786  1  E9 37                sbc #'A' - 10
000788  1  90 ED                bcc ack
00078A  1               
00078A  1               ;----------------------------------------------------------------------
00078A  1               ; push an user variable
00078A  1               var_:
00078A  1  AA                   tax
00078B  1  A9 B0                lda #<vars
00078D  1  85 B6                sta tos + 0
00078F  1  A9 0D                lda #>vars
000791  1  85 B7                sta tos + 1
000793  1  4C A2 07             jmp a2z
000796  1               
000796  1               ;----------------------------------------------------------------------
000796  1               ; push a mint variable
000796  1               sysVar_:
000796  1  AA                   tax
000797  1  A9 70                lda #<vsys
000799  1  85 B6                sta tos + 0
00079B  1  A9 0D                lda #>vsys
00079D  1  85 B7                sta tos + 1
00079F  1  4C A2 07             jmp a2z
0007A2  1               
0007A2  1               ;----------------------------------------------------------------------
0007A2  1               ; push a reference into stack
0007A2  1               a2z:
0007A2  1  38                   sec
0007A3  1  8A                   txa
0007A4  1  E9 61                sbc #'a'
0007A6  1  0A                   asl
0007A7  1  20 D3 05             jsr add2tos
0007AA  1                       ; fall thru
0007AA  1               ;----------------------------------------------------------------------
0007AA  1               pends:
0007AA  1  20 35 03             jsr spush
0007AD  1                       ; next
0007AD  1  6C 7E 0D             jmp (vNext)
0007B0  1               
0007B0  1               ;----------------------------------------------------------------------
0007B0  1               ; ascii code
0007B0  1               charCode_:
0007B0  1  20 A7 05             jsr seekps
0007B3  1                       ; fall thru
0007B3  1               
0007B3  1               bytos:
0007B3  1  85 B6                sta tos + 0
0007B5  1  A9 00                lda #NUL
0007B7  1  85 B7                sta tos + 1
0007B9  1  F0 EF                beq pends
0007BB  1               
0007BB  1               ;----------------------------------------------------------------------
0007BB  1               ; convert a decimal value to binary
0007BB  1               dec_:
0007BB  1  20 65 07             jsr nul2tos
0007BE  1               @loop:
0007BE  1  20 A7 05             jsr seekps
0007C1  1  20 6C 07             jsr isdec
0007C4  1  B0 E4                bcs pends
0007C6  1               @uval:
0007C6  1  20 D3 05             jsr add2tos
0007C9  1  20 F0 07             jsr mul10
0007CC  1  18                   clc
0007CD  1  90 EF                bcc @loop
0007CF  1               
0007CF  1               ;----------------------------------------------------------------------
0007CF  1               ; convert a hexadecimal value to binary
0007CF  1               hex_:
0007CF  1  20 65 07             jsr nul2tos
0007D2  1               @loop:
0007D2  1  20 A7 05             jsr seekps
0007D5  1  20 6C 07             jsr isdec
0007D8  1  90 07                bcc @uval
0007DA  1  20 7B 07             jsr ishex
0007DD  1  90 02                bcc @uval
0007DF  1  B0 C9                bcs pends
0007E1  1               @uval:
0007E1  1  20 D3 05             jsr add2tos
0007E4  1  20 05 08             jsr mul16
0007E7  1  18                   clc
0007E8  1  90 E8                bcc @loop
0007EA  1               
0007EA  1               ;----------------------------------------------------------------------
0007EA  1               depth_:
0007EA  1                       ; stacks moves backwards
0007EA  1  38                   sec
0007EB  1  8A                   txa
0007EC  1  4A                   lsr ; words
0007ED  1  4C B3 07             jmp bytos
0007F0  1               
0007F0  1               ;----------------------------------------------------------------------
0007F0  1               ; multiply by ten
0007F0  1               ; 2x + 8x
0007F0  1               mul10:
0007F0  1                       ; 2x
0007F0  1  20 00 06             jsr addt2t
0007F3  1  A5 B6                lda tos + 0
0007F5  1  85 B8                sta nos + 0
0007F7  1  A5 B7                lda tos + 1
0007F9  1  85 B9                sta nos + 1
0007FB  1                       ; 2x
0007FB  1  20 00 06             jsr addt2t
0007FE  1                       ; 2x
0007FE  1  20 00 06             jsr addt2t
000801  1                       ; 2x + 8x
000801  1  20 F2 05             jsr addn2t
000804  1  60                   rts
000805  1               
000805  1               ;----------------------------------------------------------------------
000805  1               ; multiply by sixteen
000805  1               mul16:
000805  1  A0 04                ldy #4
000807  1               @loop:
000807  1  06 B6                asl tos + 0
000809  1  85 B6                sta tos + 0
00080B  1  26 B7                rol tos + 1
00080D  1  85 B7                sta tos + 1
00080F  1  88                   dey
000810  1  D0 F5                bne @loop
000812  1  60                   rts
000813  1               
000813  1               ;----------------------------------------------------------------------
000813  1               ; skip to eol, crlf
000813  1               comment_:
000813  1  A0 00                ldy #NUL
000815  1               @loop:
000815  1  C8                   iny
000816  1  F0 08                beq @ends   ; limit 256
000818  1  B1 B0                lda (ipt), y
00081A  1  F0 04                beq @ends
00081C  1  C9 0D                cmp #CR
00081E  1  D0 F5                bne @loop
000820  1               @ends:
000820  1  98                   tya
000821  1  4C 9B 05             jmp add2ps
000824  1               
000824  1               ;----------------------------------------------------------------------
000824  1               ; print hexadecimal
000824  1               hdot_:
000824  1  20 40 03             jsr spull
000827  1  20 43 07             jsr printhex
00082A  1  4C 36 08             jmp dotsp
00082D  1               
00082D  1               ;----------------------------------------------------------------------
00082D  1               ; print decimal
00082D  1               dot_:
00082D  1  20 40 03             jsr spull
000830  1  20 0B 07             jsr printdec
000833  1  4C 36 08             jmp dotsp
000836  1               
000836  1               ;----------------------------------------------------------------------
000836  1               ; print space
000836  1               dotsp:
000836  1  A9 20                lda #' '
000838  1  20 1A 03             jsr putch
00083B  1                       ; next
00083B  1  6C 7E 0D             jmp (vNext)
00083E  1               
00083E  1               ;----------------------------------------------------------------------
00083E  1               newln_:
00083E  1  20 44 08             jsr crlf
000841  1                       ; next
000841  1  6C 7E 0D             jmp (vNext)
000844  1               
000844  1               ;----------------------------------------------------------------------
000844  1               crlf:
000844  1  20 C8 06             jsr printStr
000847  1  0D 0A 00             .asciiz "\r\n"
00084A  1  60                   rts
00084B  1               
00084B  1               ;----------------------------------------------------------------------
00084B  1               prompt:
00084B  1  20 C8 06             jsr printStr
00084E  1  0D 0A 3E 20          .asciiz "\r\n> "
000852  1  00           
000853  1  60                   rts
000854  1               
000854  1               ;----------------------------------------------------------------------
000854  1               ; how many ? 14
000854  1               printStk_:
000854  1  20 B8 08             jsr enter
000857  1                       ;.asciiz  "\\a@2-\\D1-(",$22,"@\\b@\\(,)(.)2-)'"
000857  1  5C 61 40 32          .asciiz  "\\a@2-\\D1-(14@\\b@\\(,)(.)2-)'"
00085B  1  2D 5C 44 31  
00085F  1  2D 28 31 34  
000873  1                       ; next
000873  1  6C 7E 0D             jmp (vNext)
000876  1               
000876  1               ;----------------------------------------------------------------------
000876  1               ; 6502 is memory mapped IO, just read
000876  1               inPort_:
000876  1  4C 67 04             jmp cfetch_
000879  1               
000879  1               ;----------------------------------------------------------------------
000879  1               ; 6502 is memory mapped IO, just write
000879  1               outPort_:
000879  1  4C 43 04             jmp cstore_
00087C  1               
00087C  1               ;----------------------------------------------------------------------
00087C  1               ; copy and update
00087C  1               compNext:
00087C  1               
00087C  1                       ; pull heap
00087C  1  20 B2 05             jsr heap2nos
00087F  1               
00087F  1                       ; pull value
00087F  1  20 40 03             jsr spull
000882  1               
000882  1                       ; byte
000882  1  A0 00                ldy #NUL
000884  1  A5 B6                lda tos + 0
000886  1  91 B8                sta (nos), y
000888  1  C8                   iny
000889  1               
000889  1  A5 B3                lda vByteMode + 0
00088B  1  D0 05                bne @isbm
00088D  1               
00088D  1                       ; word
00088D  1  A5 B7                lda tos + 1
00088F  1  91 B8                sta (nos), y
000891  1  C8                   iny
000892  1               @isbm:
000892  1               
000892  1  98                   tya
000893  1  20 BD 05             jsr add2heap
000896  1                       ; fall thru
000896  1               
000896  1               ;----------------------------------------------------------------------
000896  1               ; Execute next opcode
000896  1               next:
000896  1               opt_:
000896  1  20 A7 05             jsr seekps
000899  1  A8                   tay
00089A  1  B9 70 0B             lda optcodeslo, y
00089D  1  85 B6                sta tos + 0
00089F  1  B9 F0 0B             lda optcodeshi, y
0008A2  1  85 B7                sta tos + 1
0008A4  1  6C B6 00             jmp (tos)
0008A7  1               
0008A7  1               ;----------------------------------------------------------------------
0008A7  1               ; Execute next alt opcode
0008A7  1               alt_:
0008A7  1  20 A7 05             jsr seekps
0008AA  1  A8                   tay
0008AB  1  B9 70 0C             lda altcodeslo, y
0008AE  1  85 B6                sta tos + 0
0008B0  1  B9 F0 0C             lda altcodeshi, y
0008B3  1  85 B7                sta tos + 1
0008B5  1  6C B6 00             jmp (tos)
0008B8  1               
0008B8  1               ;----------------------------------------------------------------------
0008B8  1               ; Parse inline mint, must be asciiz
0008B8  1               enter:
0008B8  1               ; pull from system stack
0008B8  1  68                   pla
0008B9  1  85 B0                sta ipt + 0
0008BB  1  68                   pla
0008BC  1  85 B1                sta ipt + 1
0008BE  1               
0008BE  1               ; jsr/rst uses return address less one, must add one :)
0008BE  1  E6 B0                inc ipt + 0
0008C0  1  90 02                bcc @nock
0008C2  1  E6 B1                inc ipt + 1
0008C4  1               @nock:
0008C4  1                       ; next
0008C4  1  6C 7E 0D             jmp (vNext)
0008C7  1               
0008C7  1               ;----------------------------------------------------------------------
0008C7  1               ; char 0, Continue from enter, past inline mint
0008C7  1               exit_:
0008C7  1  6C B0 00             jmp (ipt)
0008CA  1               
0008CA  1               ;----------------------------------------------------------------------
0008CA  1               ; Execute code from data stack
0008CA  1               ;
0008CA  1               exec_:
0008CA  1  20 40 03             jsr spull
0008CD  1  6C B6 00             jmp (tos)
0008D0  1               
0008D0  1               ;----------------------------------------------------------------------
0008D0  1               ; Interpret code from data stack
0008D0  1               go_:
0008D0  1  A5 B0                lda ipt + 0
0008D2  1  48                   pha
0008D3  1  A5 B1                lda ipt + 1
0008D5  1  48                   pha
0008D6  1                       ; pull ps from data stack
0008D6  1  B5 00                lda  0, x
0008D8  1  85 B0                sta ipt + 0
0008DA  1  B5 01                lda  1, x
0008DC  1  85 B1                sta ipt + 1
0008DE  1  E8                   inx
0008DF  1  E8                   inx
0008E0  1                       ; next
0008E0  1  6C 7E 0D             jmp (vNext)
0008E3  1               
0008E3  1               ;----------------------------------------------------------------------
0008E3  1               ret_:
0008E3  1  68                   pla
0008E4  1  85 B1                sta ipt + 1
0008E6  1  68                   pla
0008E7  1  85 B0                sta ipt + 0
0008E9  1                       ; next
0008E9  1  6C 7E 0D             jmp (vNext)
0008EC  1               
0008EC  1               ;----------------------------------------------------------------------
0008EC  1               ; Execute code from a user function
0008EC  1               call_:
0008EC  1               
0008EC  1  A8                   tay
0008ED  1  A5 B0                lda ipt + 0
0008EF  1  48                   pha
0008F0  1  A5 B1                lda ipt + 1
0008F2  1  48                   pha
0008F3  1  98                   tya
0008F4  1               
0008F4  1  20 08 09             jsr lookupDefs
0008F7  1               
0008F7  1                       ; update instruction pointer
0008F7  1  A0 00                ldy #NUL
0008F9  1  B1 B6                lda (tos), y
0008FB  1  85 B0                sta ipt + 0
0008FD  1  C8                   iny
0008FE  1  B1 B6                lda (tos), y
000900  1  85 B1                sta ipt + 1
000902  1               
000902  1                       ; next
000902  1  6C 7E 0D             jmp (vNext)
000905  1               
000905  1               ;----------------------------------------------------------------------
000905  1               lookupDeft:
000905  1  8D 7A 0D             sta vEdited
000908  1                       ; fall thru
000908  1               
000908  1               ;----------------------------------------------------------------------
000908  1               lookupDefs:
000908  1  38                   sec
000909  1  E9 41                sbc #'A'
00090B  1  0A                   asl
00090C  1  A8                   tay
00090D  1                       ; offset
00090D  1  18                   clc
00090E  1  6D 78 0D             adc vDefs + 0
000911  1  85 B6                sta tos + 0
000913  1  A9 00                lda #NUL
000915  1  6D 79 0D             adc vDefs + 1
000918  1  85 B7                sta tos + 1
00091A  1  60                   rts
00091B  1               
00091B  1               ;----------------------------------------------------------------------
00091B  1               ; Copy a user macro to tib
00091B  1               ; lookup up def based on a number at data stack
00091B  1               ;
00091B  1               editDef_:
00091B  1                       ; which one
00091B  1  20 40 03             jsr spull
00091E  1               
00091E  1                       ; toChar
00091E  1  18                   clc
00091F  1  A9 41                lda #'A'
000921  1  65 B6                adc tos + 0
000923  1  AA                   tax
000924  1  20 05 09             jsr lookupDeft
000927  1               
000927  1                       ; origin
000927  1  B1 B6                lda (tos), y
000929  1  85 B8                sta nos + 0
00092B  1  C8                   iny
00092C  1  B1 B6                lda (tos), y
00092E  1  85 B9                sta nos + 1
000930  1               
000930  1  A0 00                ldy #NUL
000932  1                       ; empty ?
000932  1  B1 B8                lda (nos), y
000934  1  F0 29                beq @editDef3    ; is NUL ?
000936  1  C9 3B                cmp #';'        ; is end ?
000938  1  F0 25                beq @editDef3
00093A  1               
00093A  1                       ; copy
00093A  1               
00093A  1  20 CA 05             jsr tib2tos
00093D  1               
00093D  1  A9 3A                lda #':'
00093F  1  20 6C 09             jsr writeChar
000942  1  A9 01                lda #1
000944  1  20 D3 05             jsr add2tos
000947  1               
000947  1  8A                   txa
000948  1  20 6C 09             jsr writeChar
00094B  1  A9 01                lda #1
00094D  1  20 D3 05             jsr add2tos
000950  1               
000950  1  18                   clc
000951  1  90 03                bcc @editDef2
000953  1               
000953  1               @editDef1:
000953  1  C8                   iny
000954  1  F0 09                beq @editDef3
000956  1               
000956  1               @editDef2:
000956  1  B1 B8                lda (nos), y
000958  1  20 6C 09             jsr writeChar
00095B  1  C9 3B                cmp #';'
00095D  1  D0 F4                bne @editDef1
00095F  1               
00095F  1               @editDef3:
00095F  1  A9 00                lda #<tib
000961  1  8D 74 0D             sta vTIBPtr + 0
000964  1  A9 02                lda #>tib
000966  1  8D 75 0D             sta vTIBPtr + 1
000969  1                       ; next
000969  1  6C 7E 0D             jmp (vNext)
00096C  1               
00096C  1               ;----------------------------------------------------------------------
00096C  1               writeChar:
00096C  1  91 B6                sta (tos), y
00096E  1  4C 1A 03             jmp putch
000971  1               
000971  1               ;----------------------------------------------------------------------
000971  1               ; skip spaces
000971  1               nosp:
000971  1  20 A7 05             jsr seekps
000974  1  C9 20                cmp #' '
000976  1  F0 F9                beq nosp
000978  1  60                   rts
000979  1               
000979  1               ;----------------------------------------------------------------------
000979  1               group_:
000979  1               
000979  1  20 40 03             jsr spull
00097C  1                       ;-----------------------
00097C  1                       ; multiply by GROUP of 64
00097C  1                       ; swap byte
00097C  1  A5 B6                lda tos + 0
00097E  1  85 B9                sta nos + 1
000980  1  A9 00                lda #NUL
000982  1  85 B8                sta nos + 0
000984  1                       ; group is 64 bytes
000984  1  46 B9                lsr nos + 1
000986  1  66 B8                ror nos + 0
000988  1  46 B9                lsr nos + 1
00098A  1  66 B8                ror nos + 0
00098C  1                       ;-----------------------
00098C  1                       ; save last group
00098C  1  AD 78 0D             lda vDefs + 0
00098F  1  48                   pha
000990  1  AD 79 0D             lda vDefs + 1
000993  1  48                   pha
000994  1                       ;-----------------------
000994  1                       ; update group
000994  1  18                   clc
000995  1  AD F0 0D             lda defs + 0
000998  1  65 B8                adc nos + 0
00099A  1  8D 78 0D             sta vDefs + 0
00099D  1  AD F1 0D             lda defs + 1
0009A0  1  65 B9                adc nos + 1
0009A2  1  8D 79 0D             sta vDefs + 1
0009A5  1               
0009A5  1                       ; next
0009A5  1  6C 7E 0D             jmp (vNext)
0009A8  1               
0009A8  1               ;----------------------------------------------------------------------
0009A8  1               endGroup_:
0009A8  1                       ; load last group
0009A8  1  68                   pla
0009A9  1  8D 78 0D             sta vDefs + 0
0009AC  1  68                   pla
0009AD  1  8D 79 0D             sta vDefs + 1
0009B0  1                       ; next
0009B0  1  6C 7E 0D             jmp (vNext)
0009B3  1               
0009B3  1               ;----------------------------------------------------------------------
0009B3  1               getRef_:
0009B3  1  20 A7 05             jsr seekps
0009B6  1  20 08 09             jsr lookupDefs
0009B9  1  4C 6D 04             jmp fetch_
0009BC  1               
0009BC  1               ;----------------------------------------------------------------------
0009BC  1               arrDef_:
0009BC  1  A9 00                lda #FALSE
0009BE  1  F0 02                beq arrDefs
0009C0  1               
0009C0  1               ;----------------------------------------------------------------------
0009C0  1               cArrDef_:
0009C0  1  A9 01                lda #TRUE
0009C2  1                       ; fall thru
0009C2  1               
0009C2  1               ;----------------------------------------------------------------------
0009C2  1               arrDefs:
0009C2  1                       ; save array mode
0009C2  1  85 B3                sta vByteMode
0009C4  1               
0009C4  1                       ; save array start
0009C4  1  AD 80 0D             lda vHeap + 0
0009C7  1  48                   pha
0009C8  1  AD 81 0D             lda vHeap + 1
0009CB  1  48                   pha
0009CC  1               
0009CC  1                       ; array next
0009CC  1  A9 7C                lda #<compNext
0009CE  1  8D 7E 0D             sta vNext + 0
0009D1  1  A9 08                lda #>compNext
0009D3  1  8D 7F 0D             sta vNext + 1
0009D6  1               
0009D6  1                       ; next
0009D6  1  4C 96 08             jmp next
0009D9  1               
0009D9  1               ;----------------------------------------------------------------------
0009D9  1               arrEnd_:
0009D9  1               
0009D9  1                       ; start of array
0009D9  1  CA                   dex
0009DA  1  CA                   dex
0009DB  1  48                   pha
0009DC  1  95 00                sta 0, x
0009DE  1  48                   pha
0009DF  1  95 01                sta 1, x
0009E1  1               
0009E1  1                       ; bytes
0009E1  1  38                   sec
0009E2  1  AD 80 0D             lda vHeap + 0
0009E5  1  E5 B6                sbc tos + 0
0009E7  1  85 B6                sta tos + 0
0009E9  1  AD 81 0D             lda vHeap + 1
0009EC  1  E5 B7                sbc tos + 1
0009EE  1  85 B7                sta tos + 1
0009F0  1               
0009F0  1  A5 B3                lda vByteMode
0009F2  1  D0 04                bne @isne
0009F4  1                       ; words
0009F4  1  46 B6                lsr tos + 0
0009F6  1  66 B7                ror tos + 1
0009F8  1               @isne:
0009F8  1                       ; save size
0009F8  1  20 35 03             jsr spush
0009FB  1               
0009FB  1                       ; common next
0009FB  1  A9 96                lda #<next
0009FD  1  8D 7E 0D             sta vNext + 0
000A00  1  A9 08                lda #>next
000A02  1  8D 7F 0D             sta vNext + 1
000A05  1               
000A05  1                       ; next
000A05  1  4C 96 08             jmp next
000A08  1               
000A08  1               ;----------------------------------------------------------------------
000A08  1               def_:
000A08  1                       ; must be a A-Z, can't be space
000A08  1  20 A7 05             jsr seekps
000A0B  1  20 08 09             jsr lookupDefs
000A0E  1               
000A0E  1                       ; get heap
000A0E  1  20 B2 05             jsr heap2nos
000A11  1               
000A11  1                       ; put heap at list
000A11  1  A5 B8                lda nos + 0
000A13  1  91 B6                sta (tos), y
000A15  1  C8                   iny
000A16  1  A5 B9                lda nos + 1
000A18  1  91 B6                sta (tos), y
000A1A  1               
000A1A  1                       ; copy to heap
000A1A  1  A0 00                ldy #NUL
000A1C  1               @loop:
000A1C  1  B1 B0                lda (ipt), y
000A1E  1  91 B8                sta (nos), y
000A20  1  F0 07                beq @ends
000A22  1  C8                   iny
000A23  1  F0 04                beq @ends
000A25  1  C9 3B                cmp #';'
000A27  1  D0 F3                bne @loop
000A29  1               @ends:
000A29  1                       ; update heap
000A29  1  98                   tya
000A2A  1  AA                   tax
000A2B  1  20 BD 05             jsr add2heap
000A2E  1                       ; update instruction pointer
000A2E  1  8A                   txa
000A2F  1  4C 9B 05             jmp add2ps
000A32  1               
000A32  1               ;----------------------------------------------------------------------
000A32  1               
000A32  1               ;----------------------------------------------------------------------
000A32  1               break_:
000A32  1  20 40 03             jsr spull
000A35  1  A5 B6                lda tos + 0
000A37  1  F0 14                beq iseq
000A39  1               skframe:
000A39  1                       ; skip a frame 3 words
000A39  1  68                   pla
000A3A  1  68                   pla
000A3B  1  68                   pla
000A3C  1  68                   pla
000A3D  1  68                   pla
000A3E  1  68                   pla
000A3F  1                       ; skip while nest
000A3F  1               skipnest:
000A3F  1  A9 01                lda #$01
000A41  1  85 B2                sta nest
000A43  1               @loop:
000A43  1  20 A7 05             jsr seekps
000A46  1  20 9A 06             jsr nesting
000A49  1  A5 B2                lda nest
000A4B  1  D0 F6                bne @loop
000A4D  1               iseq:
000A4D  1                       ; parse frame
000A4D  1  6C 7E 0D             jmp (vNext)
000A50  1               
000A50  1               ;----------------------------------------------------------------------
000A50  1               ; Left parentesis ( begins a loop
000A50  1               begin_:
000A50  1               
000A50  1                       ; tos is zero ?
000A50  1  20 40 03             jsr spull
000A53  1  A5 B6                lda tos + 0
000A55  1  F0 E8                beq skipnest
000A57  1               
000A57  1                       ; do a frame
000A57  1                       ; counter
000A57  1  A9 00                lda #NUL
000A59  1  48                   pha
000A5A  1  48                   pha
000A5B  1                       ; limit
000A5B  1  A5 B6                lda tos + 0
000A5D  1  48                   pha
000A5E  1  A5 B7                lda tos + 1
000A60  1  48                   pha
000A61  1                       ; pointer
000A61  1  A5 B0                lda ipt + 0
000A63  1  48                   pha
000A64  1  A5 B1                lda ipt + 1
000A66  1  48                   pha
000A67  1               
000A67  1                       ; next
000A67  1  6C 7E 0D             jmp (vNext)
000A6A  1               
000A6A  1               ;----------------------------------------------------------------------
000A6A  1               ; Right parentesis ) again a loop
000A6A  1               again_:
000A6A  1                       ; check if IFTEMode $FFFF
000A6A  1  86 B4                stx xpf
000A6C  1  BA                   tsx
000A6D  1  B5 00                lda 0, x
000A6F  1  35 01                and 1, x
000A71  1  C9 FF                cmp #$FF
000A73  1  D0 0F                bne @again1
000A75  1               
000A75  1                       ; push FALSE
000A75  1  A6 B4                ldx xpf
000A77  1  A9 00                lda #0
000A79  1  CA                   dex
000A7A  1  CA                   dex
000A7B  1  95 00                sta 0, x
000A7D  1  95 01                sta 1, x
000A7F  1               
000A7F  1                       ; drop IFTEMmode
000A7F  1  68                   pla
000A80  1  68                   pla
000A81  1               
000A81  1                       ; next
000A81  1  6C 7E 0D             jmp (vNext)
000A84  1               
000A84  1               @again1:
000A84  1                       ; test end
000A84  1  B5 02                lda 2, x
000A86  1  D5 00                cmp 0, x
000A88  1  D0 11                bne @noend
000A8A  1  B5 03                lda 3, x
000A8C  1  D5 01                cmp 1, x
000A8E  1  D0 0B                bne @noend
000A90  1               
000A90  1                       ; end of loop
000A90  1  A6 B4                ldx xpf
000A92  1  68                   pla
000A93  1  68                   pla
000A94  1  68                   pla
000A95  1  68                   pla
000A96  1  68                   pla
000A97  1  68                   pla
000A98  1                       ; next
000A98  1  6C 7E 0D             jmp (vNext)
000A9B  1               
000A9B  1               @noend:
000A9B  1                       ; increase counter
000A9B  1  F6 00                inc 0, x
000A9D  1  D0 02                bne @novr
000A9F  1  F6 01                inc 1, x
000AA1  1               @novr:
000AA1  1               
000AA1  1                       ; return at begin
000AA1  1  B5 04                lda 4, x
000AA3  1  85 B0                sta ipt + 0
000AA5  1  B5 05                lda 5, x
000AA7  1  85 B1                sta ipt + 1
000AA9  1               
000AA9  1                       ; next
000AA9  1  A6 B4                ldx xpf
000AAB  1  6C 7E 0D             jmp (vNext)
000AAE  1               
000AAE  1               ; ZZZZZ
000AAE  1               ;----------------------------------------------------------------------
000AAE  1               ; do not update indx
000AAE  1               j_:
000AAE  1  86 B4                stx xpf
000AB0  1  BA                   tsx
000AB1  1  CA                   dex
000AB2  1  CA                   dex
000AB3  1  CA                   dex
000AB4  1  CA                   dex
000AB5  1  CA                   dex
000AB6  1  CA                   dex
000AB7  1  8A                   txa
000AB8  1  A6 B4                ldx xpf
000ABA  1  4C C3 0A             jmp index
000ABD  1               
000ABD  1               ;----------------------------------------------------------------------
000ABD  1               ; do not update indx
000ABD  1               i_:
000ABD  1  86 B4                stx xpf
000ABF  1  BA                   tsx
000AC0  1  8A                   txa
000AC1  1  A6 B4                ldx xpf
000AC3  1                       ; fall through
000AC3  1               
000AC3  1               ;----------------------------------------------------------------------
000AC3  1               index:
000AC3  1               ; WTF ?
000AC3  1  68                   pla
000AC4  1  85 B6                sta tos + 0
000AC6  1  68                   pla
000AC7  1  85 B7                sta tos + 1
000AC9  1               
000AC9  1  A5 B6                lda tos + 0
000ACB  1  48                   pha
000ACC  1  A5 B7                lda tos + 1
000ACE  1  48                   pha
000ACF  1               
000ACF  1  4C AA 07             jmp pends
000AD2  1               
000AD2  1               ;----------------------------------------------------------------------
000AD2  1               ifte_:
000AD2  1  20 40 03             jsr spull
000AD5  1  A5 B6                lda tos + 0
000AD7  1  05 B7                ora tos + 1
000AD9  1  D0 08                bne @istrue
000ADB  1  E6 B6                inc tos + 0
000ADD  1  20 35 03             jsr spush
000AE0  1  4C 3F 0A             jmp skipnest
000AE3  1               @istrue:
000AE3  1  A9 FF                lda #$FF
000AE5  1  48                   pha
000AE6  1  48                   pha
000AE7  1  6C 7E 0D             jmp (vNext)
000AEA  1               
000AEA  1               ;----------------------------------------------------------------------
000AEA  1               ; verify stack
000AEA  1               etx_:
000AEA  1  8A                   txa
000AEB  1  C9 C0                cmp #STKENDS    ; bytes
000AED  1  30 04                bmi @ends
000AEF  1  A9 FF                lda #$FF        ; stack top
000AF1  1  AA                   tax
000AF2  1  9A                   txs
000AF3  1               @ends:
000AF3  1  4C 22 06             jmp interpret
000AF6  1               
000AF6  1               ;----------------------------------------------------------------------
000AF6  1               iSysVars:
000AF6  1  FF 00                .word  S0               ; a vS0
000AF8  1  00 00                .word  FALSE            ; b vBase16
000AFA  1  00 02                .word  tib              ; c vTIBPtr
000AFC  1  F0 0D                .word  defs             ; d vDEFS
000AFE  1  00 00                .word  FALSE            ; e vEdited
000B00  1  FF 01                .word  R0               ; f vR0
000B02  1  96 08                .word  next             ; g dispatcher
000B04  1  9C 0F                .word  heap             ; h vHeap
000B06  1               fSysVars:
000B06  1               
000B06  1               dysys = fSysVars - iSysVars
000B06  1               
000B06  1               ;----------------------------------------------------------------------
000B06  1               
000B06  1               main_:
000B06  1               
000B06  1               ; default system values
000B06  1  A9 F6                lda #<iSysVars
000B08  1  85 B6                sta tos + 0
000B0A  1  A9 0A                lda #>iSysVars
000B0C  1  85 B7                sta tos + 1
000B0E  1  A9 70                lda #<vsys
000B10  1  85 B8                sta nos + 0
000B12  1  A9 0D                lda #>vsys
000B14  1  85 B9                sta nos + 1
000B16  1  A0 10                ldy #dysys
000B18  1               @loop:
000B18  1  B1 B6                lda (tos), y
000B1A  1  91 B8                sta (nos), y
000B1C  1  88                   dey
000B1D  1  D0 F9                bne @loop
000B1F  1               
000B1F  1               ; default function
000B1F  1  A9 F0                lda #<defs
000B21  1  85 B6                sta tos + 0
000B23  1  A9 0D                lda #>defs
000B25  1  85 B7                sta tos + 1
000B27  1               
000B27  1  A2 00                ldx #NUL
000B29  1               @loop2:
000B29  1  A0 00                ldy #NUL
000B2B  1               @loop3:
000B2B  1                       ; default
000B2B  1  A9 30                lda #<empty_
000B2D  1  91 B6                sta (tos), y
000B2F  1  C8                   iny
000B30  1  A9 0F                lda #>empty_
000B32  1  91 B6                sta (tos), y
000B34  1  C8                   iny
000B35  1  C0 40                cpy #GRPSIZE
000B37  1  D0 F2                bne @loop3
000B39  1  E8                   inx
000B3A  1  E0 05                cpx #NUMGRPS
000B3C  1  F0 0E                beq @ends
000B3E  1               
000B3E  1                       ; increment
000B3E  1  18                   clc
000B3F  1  A5 B6                lda tos + 0
000B41  1  69 40                adc #GRPSIZE
000B43  1  85 B6                sta tos + 0
000B45  1  90 02                bcc @next
000B47  1  E6 B7                inc tos + 1
000B49  1               @next:
000B49  1  18                   clc
000B4A  1  90 DD                bcc @loop2
000B4C  1               @ends:
000B4C  1                       ; all done
000B4C  1               
000B4C  1               ; safe
000B4C  1  A9 96                lda #<next
000B4E  1  8D 7E 0D             sta vNext + 0
000B51  1  A9 08                lda #>next
000B53  1  8D 7F 0D             sta vNext + 1
000B56  1               
000B56  1               mint_:
000B56  1               ; prompt
000B56  1  20 C8 06             jsr printStr
000B59  1  4D 49 4E 54          .asciiz "MINT 6502 V1.0\r\n"
000B5D  1  20 36 35 30  
000B61  1  32 20 56 31  
000B6A  1               
000B6A  1                       ; auto reset
000B6A  1  20 22 06             jsr interpret
000B6D  1               
000B6D  1  4C 56 0B             jmp mint_
000B70  1               
000B70  1               ;----------------------------------------------------------------------
000B70  1               ;optcodes: parsed by opt_ (next)
000B70  1               ;altcodes: parsed by alt_
000B70  1               ;ctlcodes: maybe in a future...
000B70  1               
000B70  1               ; *********************************************************************
000B70  1               ; Jump Tables, optmized for single index
000B70  1               ; points the LSB and MSB of functions
000B70  1               ; each uses 127 bytes
000B70  1               ; *********************************************************************
000B70  1               
000B70  1               ; .align $100
000B70  1               
000B70  1               ; using pla, pla, rts, references must be one less
000B70  1               ;----------------------------------------------------------------------
000B70  1               optcodeslo:
000B70  1  C7              .byte  <(exit_)    ;   NUL
000B71  1  98              .byte  <(nop_)     ;   SOH
000B72  1  98              .byte  <(nop_)     ;   STX
000B73  1  EA              .byte  <(etx_)     ;   ETX
000B74  1  98              .byte  <(nop_)     ;   EOT
000B75  1  98              .byte  <(nop_)     ;   ENQ
000B76  1  98              .byte  <(nop_)     ;   ACK
000B77  1  98              .byte  <(nop_)     ;   BEL
000B78  1  98              .byte  <(nop_)     ;   BS
000B79  1  98              .byte  <(nop_)     ;   TAB
000B7A  1  98              .byte  <(nop_)     ;   LF
000B7B  1  98              .byte  <(nop_)     ;   VT
000B7C  1  98              .byte  <(nop_)     ;   FF
000B7D  1  98              .byte  <(nop_)     ;   CR
000B7E  1  98              .byte  <(nop_)     ;   SO
000B7F  1  98              .byte  <(nop_)     ;   SI
000B80  1  98              .byte  <(nop_)     ;   DLE
000B81  1  98              .byte  <(nop_)     ;   DC1
000B82  1  98              .byte  <(nop_)     ;   DC2
000B83  1  98              .byte  <(nop_)     ;   DC3
000B84  1  98              .byte  <(nop_)     ;   DC4
000B85  1  98              .byte  <(nop_)     ;   NAK
000B86  1  98              .byte  <(nop_)     ;   SYN
000B87  1  98              .byte  <(nop_)     ;   ETB
000B88  1  98              .byte  <(nop_)     ;   CAN
000B89  1  98              .byte  <(nop_)     ;   EM
000B8A  1  98              .byte  <(nop_)     ;   SUB
000B8B  1  98              .byte  <(nop_)     ;   ESC
000B8C  1  98              .byte  <(nop_)     ;   FS
000B8D  1  98              .byte  <(nop_)     ;   GS
000B8E  1  98              .byte  <(nop_)     ;   RS
000B8F  1  98              .byte  <(nop_)     ;   US
000B90  1  98              .byte  <(nop_)     ;   SP
000B91  1  49              .byte  <(store_)   ;   !
000B92  1  5E              .byte  <(dup_)     ;   "
000B93  1  CF              .byte  <(hex_)     ;    #
000B94  1  78              .byte  <(swap_)    ;    $
000B95  1  6B              .byte  <(over_)    ;    %
000B96  1  A0              .byte  <(and_)     ;    &
000B97  1  59              .byte  <(drop_)    ;    '
000B98  1  50              .byte  <(begin_)   ;    (
000B99  1  6A              .byte  <(again_)   ;    )
000B9A  1  61              .byte  <(mul_)     ;    * multiply 16x16
000B9B  1  C7              .byte  <(add_)     ;    +
000B9C  1  24              .byte  <(hdot_)    ;    ,
000B9D  1  D5              .byte  <(sub_)     ;    -
000B9E  1  2D              .byte  <(dot_)     ;    .
000B9F  1  36              .byte  <(div_)     ;    / divide 16x16
000BA0  1  BB              .byte  <(dec_)     ;    0
000BA1  1  BB              .byte  <(dec_)     ;    1
000BA2  1  BB              .byte  <(dec_)     ;    2
000BA3  1  BB              .byte  <(dec_)     ;    3
000BA4  1  BB              .byte  <(dec_)     ;    4
000BA5  1  BB              .byte  <(dec_)     ;    5
000BA6  1  BB              .byte  <(dec_)     ;    6
000BA7  1  BB              .byte  <(dec_)     ;    7
000BA8  1  BB              .byte  <(dec_)     ;    8
000BA9  1  BB              .byte  <(dec_)     ;    9
000BAA  1  08              .byte  <(def_)     ;    :
000BAB  1  E3              .byte  <(ret_)     ;    ;
000BAC  1  0A              .byte  <(lt_)      ;    <
000BAD  1  03              .byte  <(eq_)      ;    =
000BAE  1  11              .byte  <(gt_)      ;    >
000BAF  1  B3              .byte  <(getRef_)  ;    ?
000BB0  1  6D              .byte  <(fetch_)   ;    @
000BB1  1  EC              .byte  <(call_)    ;    A
000BB2  1  EC              .byte  <(call_)    ;    B
000BB3  1  EC              .byte  <(call_)    ;    C
000BB4  1  EC              .byte  <(call_)    ;    D
000BB5  1  EC              .byte  <(call_)    ;    E
000BB6  1  EC              .byte  <(call_)    ;    F
000BB7  1  EC              .byte  <(call_)    ;    G
000BB8  1  EC              .byte  <(call_)    ;    H
000BB9  1  EC              .byte  <(call_)    ;    I
000BBA  1  EC              .byte  <(call_)    ;    J
000BBB  1  EC              .byte  <(call_)    ;    K
000BBC  1  EC              .byte  <(call_)    ;    L
000BBD  1  EC              .byte  <(call_)    ;    M
000BBE  1  EC              .byte  <(call_)    ;    N
000BBF  1  EC              .byte  <(call_)    ;    O
000BC0  1  EC              .byte  <(call_)    ;    P
000BC1  1  EC              .byte  <(call_)    ;    Q
000BC2  1  EC              .byte  <(call_)    ;    R
000BC3  1  EC              .byte  <(call_)    ;    S
000BC4  1  EC              .byte  <(call_)    ;    T
000BC5  1  EC              .byte  <(call_)    ;    U
000BC6  1  EC              .byte  <(call_)    ;    V
000BC7  1  EC              .byte  <(call_)    ;    W
000BC8  1  EC              .byte  <(call_)    ;    X
000BC9  1  EC              .byte  <(call_)    ;    Y
000BCA  1  EC              .byte  <(call_)    ;    Z
000BCB  1  BC              .byte  <(arrDef_)  ;    [
000BCC  1  A7              .byte  <(alt_)     ;    \
000BCD  1  D9              .byte  <(arrEnd_)  ;    ]
000BCE  1  BA              .byte  <(xor_)     ;    ^
000BCF  1  E5              .byte  <(neg_)     ;    _
000BD0  1  E0              .byte  <(str_)     ;    `
000BD1  1  8A              .byte  <(var_)     ;    a
000BD2  1  8A              .byte  <(var_)     ;    b
000BD3  1  8A              .byte  <(var_)     ;    c
000BD4  1  8A              .byte  <(var_)     ;    d
000BD5  1  8A              .byte  <(var_)     ;    e
000BD6  1  8A              .byte  <(var_)     ;    f
000BD7  1  8A              .byte  <(var_)     ;    g
000BD8  1  8A              .byte  <(var_)     ;    h
000BD9  1  8A              .byte  <(var_)     ;    i
000BDA  1  8A              .byte  <(var_)     ;    j
000BDB  1  8A              .byte  <(var_)     ;    k
000BDC  1  8A              .byte  <(var_)     ;    l
000BDD  1  8A              .byte  <(var_)     ;    m
000BDE  1  8A              .byte  <(var_)     ;    n
000BDF  1  8A              .byte  <(var_)     ;    o
000BE0  1  8A              .byte  <(var_)     ;    p
000BE1  1  8A              .byte  <(var_)     ;    q
000BE2  1  8A              .byte  <(var_)     ;    r
000BE3  1  8A              .byte  <(var_)     ;    s
000BE4  1  8A              .byte  <(var_)     ;    t
000BE5  1  8A              .byte  <(var_)     ;    u
000BE6  1  8A              .byte  <(var_)     ;    v
000BE7  1  8A              .byte  <(var_)     ;    w
000BE8  1  8A              .byte  <(var_)     ;    x
000BE9  1  8A              .byte  <(var_)     ;    y
000BEA  1  8A              .byte  <(var_)     ;    z
000BEB  1  22              .byte  <(shl_)     ;    {
000BEC  1  AD              .byte  <(or_)      ;    |
000BED  1  29              .byte  <(shr_)     ;    }
000BEE  1  E8              .byte  <(inv_)     ;    ~
000BEF  1  98              .byte  <(nop_)     ;    backspace
000BF0  1               
000BF0  1               optcodeshi:
000BF0  1  08              .byte  >(exit_)    ;   NUL
000BF1  1  05              .byte  >(nop_)     ;   SOH
000BF2  1  05              .byte  >(nop_)     ;   STX
000BF3  1  0A              .byte  >(etx_)     ;   ETX
000BF4  1  05              .byte  >(nop_)     ;   EOT
000BF5  1  05              .byte  >(nop_)     ;   ENQ
000BF6  1  05              .byte  >(nop_)     ;   ACK
000BF7  1  05              .byte  >(nop_)     ;   BEL
000BF8  1  05              .byte  >(nop_)     ;   BS
000BF9  1  05              .byte  >(nop_)     ;   TAB
000BFA  1  05              .byte  >(nop_)     ;   LF
000BFB  1  05              .byte  >(nop_)     ;   VT
000BFC  1  05              .byte  >(nop_)     ;   FF
000BFD  1  05              .byte  >(nop_)     ;   CR
000BFE  1  05              .byte  >(nop_)     ;   SO
000BFF  1  05              .byte  >(nop_)     ;   SI
000C00  1  05              .byte  >(nop_)     ;   DLE
000C01  1  05              .byte  >(nop_)     ;   DC1
000C02  1  05              .byte  >(nop_)     ;   DC2
000C03  1  05              .byte  >(nop_)     ;   DC3
000C04  1  05              .byte  >(nop_)     ;   DC4
000C05  1  05              .byte  >(nop_)     ;   NAK
000C06  1  05              .byte  >(nop_)     ;   SYN
000C07  1  05              .byte  >(nop_)     ;   ETB
000C08  1  05              .byte  >(nop_)     ;   CAN
000C09  1  05              .byte  >(nop_)     ;   EM
000C0A  1  05              .byte  >(nop_)     ;   SUB
000C0B  1  05              .byte  >(nop_)     ;   ESC
000C0C  1  05              .byte  >(nop_)     ;   FS
000C0D  1  05              .byte  >(nop_)     ;   GS
000C0E  1  05              .byte  >(nop_)     ;   RS
000C0F  1  05              .byte  >(nop_)     ;   US
000C10  1  05              .byte  >(nop_)     ;   SP
000C11  1  04              .byte  >(store_)   ;   !
000C12  1  03              .byte  >(dup_)     ;   "
000C13  1  07              .byte  >(hex_)     ;    #
000C14  1  03              .byte  >(swap_)    ;    $
000C15  1  03              .byte  >(over_)    ;    %
000C16  1  03              .byte  >(and_)     ;    &
000C17  1  03              .byte  >(drop_)    ;    '
000C18  1  0A              .byte  >(begin_)   ;    (
000C19  1  0A              .byte  >(again_)   ;    )
000C1A  1  05              .byte  >(mul_)     ;    *  multiply 16x16, (multpd multpr -- LSW MSW)
000C1B  1  03              .byte  >(add_)     ;    +
000C1C  1  08              .byte  >(hdot_)    ;    ,
000C1D  1  03              .byte  >(sub_)     ;    -
000C1E  1  08              .byte  >(dot_)     ;    .
000C1F  1  05              .byte  >(div_)     ;    /  divide 16x16, (divd divs -- quo rem)
000C20  1  07              .byte  >(dec_)     ;    0
000C21  1  07              .byte  >(dec_)     ;    1
000C22  1  07              .byte  >(dec_)     ;    2
000C23  1  07              .byte  >(dec_)     ;    3
000C24  1  07              .byte  >(dec_)     ;    4
000C25  1  07              .byte  >(dec_)     ;    5
000C26  1  07              .byte  >(dec_)     ;    6
000C27  1  07              .byte  >(dec_)     ;    7
000C28  1  07              .byte  >(dec_)     ;    8
000C29  1  07              .byte  >(dec_)     ;    9
000C2A  1  0A              .byte  >(def_)     ;    :
000C2B  1  08              .byte  >(ret_)     ;    ;
000C2C  1  04              .byte  >(lt_)      ;    <( - 1)
000C2D  1  04              .byte  >(eq_)      ;    =
000C2E  1  04              .byte  >(gt_)      ;    >
000C2F  1  09              .byte  >(getRef_)  ;    ?
000C30  1  04              .byte  >(fetch_)   ;    @
000C31  1  08              .byte  >(call_)    ;    A
000C32  1  08              .byte  >(call_)    ;    B
000C33  1  08              .byte  >(call_)    ;    C
000C34  1  08              .byte  >(call_)    ;    D
000C35  1  08              .byte  >(call_)    ;    E
000C36  1  08              .byte  >(call_)    ;    F
000C37  1  08              .byte  >(call_)    ;    G
000C38  1  08              .byte  >(call_)    ;    H
000C39  1  08              .byte  >(call_)    ;    I
000C3A  1  08              .byte  >(call_)    ;    J
000C3B  1  08              .byte  >(call_)    ;    K
000C3C  1  08              .byte  >(call_)    ;    L
000C3D  1  08              .byte  >(call_)    ;    M
000C3E  1  08              .byte  >(call_)    ;    N
000C3F  1  08              .byte  >(call_)    ;    O
000C40  1  08              .byte  >(call_)    ;    P
000C41  1  08              .byte  >(call_)    ;    Q
000C42  1  08              .byte  >(call_)    ;    R
000C43  1  08              .byte  >(call_)    ;    S
000C44  1  08              .byte  >(call_)    ;    T
000C45  1  08              .byte  >(call_)    ;    U
000C46  1  08              .byte  >(call_)    ;    V
000C47  1  08              .byte  >(call_)    ;    W
000C48  1  08              .byte  >(call_)    ;    X
000C49  1  08              .byte  >(call_)    ;    Y
000C4A  1  08              .byte  >(call_)    ;    Z
000C4B  1  09              .byte  >(arrDef_)  ;    [
000C4C  1  08              .byte  >(alt_)     ;    \
000C4D  1  09              .byte  >(arrEnd_)  ;    ]
000C4E  1  03              .byte  >(xor_)     ;    ^
000C4F  1  03              .byte  >(neg_)     ;    _
000C50  1  06              .byte  >(str_)     ;    `
000C51  1  07              .byte  >(var_)     ;    a
000C52  1  07              .byte  >(var_)     ;    b
000C53  1  07              .byte  >(var_)     ;    c
000C54  1  07              .byte  >(var_)     ;    d
000C55  1  07              .byte  >(var_)     ;    e
000C56  1  07              .byte  >(var_)     ;    f
000C57  1  07              .byte  >(var_)     ;    g
000C58  1  07              .byte  >(var_)     ;    h
000C59  1  07              .byte  >(var_)     ;    i
000C5A  1  07              .byte  >(var_)     ;    j
000C5B  1  07              .byte  >(var_)     ;    k
000C5C  1  07              .byte  >(var_)     ;    l
000C5D  1  07              .byte  >(var_)     ;    m
000C5E  1  07              .byte  >(var_)     ;    n
000C5F  1  07              .byte  >(var_)     ;    o
000C60  1  07              .byte  >(var_)     ;    p
000C61  1  07              .byte  >(var_)     ;    q
000C62  1  07              .byte  >(var_)     ;    r
000C63  1  07              .byte  >(var_)     ;    s
000C64  1  07              .byte  >(var_)     ;    t
000C65  1  07              .byte  >(var_)     ;    u
000C66  1  07              .byte  >(var_)     ;    v
000C67  1  07              .byte  >(var_)     ;    w
000C68  1  07              .byte  >(var_)     ;    x
000C69  1  07              .byte  >(var_)     ;    y
000C6A  1  07              .byte  >(var_)     ;    z
000C6B  1  04              .byte  >(shl_)     ;    {
000C6C  1  03              .byte  >(or_)      ;    |
000C6D  1  04              .byte  >(shr_)     ;    }
000C6E  1  03              .byte  >(inv_)     ;    ~
000C6F  1  05              .byte  >(nop_)     ;    backspace
000C70  1               
000C70  1               ;----------------------------------------------------------------------
000C70  1               ; alternate function codes
000C70  1               ctlcodeslo:
000C70  1               altcodeslo:
000C70  1  30              .byte  <(empty_)      ; NUL ^@
000C71  1  30              .byte  <(empty_)      ; SOH ^A
000C72  1  92              .byte  <(toggleBase_) ; STX ^B
000C73  1  30              .byte  <(empty_)      ; ETX ^C
000C74  1  30              .byte  <(empty_)      ; EOT ^D
000C75  1  52              .byte  <(edit_)       ; ENQ ^E
000C76  1  30              .byte  <(empty_)      ; ACK ^F
000C77  1  30              .byte  <(empty_)      ; BEL ^G
000C78  1  32              .byte  <(backsp_)     ; BS  ^H
000C79  1  30              .byte  <(empty_)      ; TAB ^I
000C7A  1  4A              .byte  <(reedit_)     ; LF  ^J
000C7B  1  30              .byte  <(empty_)      ; VT  ^K
000C7C  1  65              .byte  <(list_)       ; FF  ^L
000C7D  1  30              .byte  <(empty_)      ; CR  ^M
000C7E  1  30              .byte  <(empty_)      ; SO  ^N
000C7F  1  30              .byte  <(empty_)      ; SI  ^O
000C80  1  81              .byte  <(printStack_) ; DLE ^P
000C81  1  30              .byte  <(empty_)      ; DC1 ^Q
000C82  1  30              .byte  <(empty_)      ; DC2 ^R
000C83  1  30              .byte  <(empty_)      ; DC3 ^S
000C84  1  30              .byte  <(empty_)      ; DC4 ^T
000C85  1  30              .byte  <(empty_)      ; NAK ^U
000C86  1  30              .byte  <(empty_)      ; SYN ^V
000C87  1  30              .byte  <(empty_)      ; ETB ^W
000C88  1  30              .byte  <(empty_)      ; CAN ^X
000C89  1  30              .byte  <(empty_)      ; EM  ^Y
000C8A  1  30              .byte  <(empty_)      ; SUB ^Z
000C8B  1  30              .byte  <(empty_)      ; ESC ^[
000C8C  1  30              .byte  <(empty_)      ; FS  ^\
000C8D  1  30              .byte  <(empty_)      ; GS  ^]
000C8E  1  30              .byte  <(empty_)      ; RS  ^^
000C8F  1  30              .byte  <(empty_)      ; US  ^_)
000C90  1  98              .byte  <(aNop_)       ; SP  ^`
000C91  1  43              .byte  <(cstore_)     ;    !
000C92  1  98              .byte  <(aNop_)       ;    "
000C93  1  98              .byte  <(aNop_)       ;    #
000C94  1  98              .byte  <(aNop_)       ;    $  ( -- adr ) text input ptr
000C95  1  98              .byte  <(aNop_)       ;    %
000C96  1  98              .byte  <(aNop_)       ;    &
000C97  1  98              .byte  <(aNop_)       ;    '
000C98  1  D2              .byte  <(ifte_)       ;    (  ( b -- )
000C99  1  98              .byte  <(aNop_)       ;    )
000C9A  1  98              .byte  <(aNop_)       ;    *
000C9B  1  73              .byte  <(incr_)       ;    +  ( adr -- ) increments variable at address
000C9C  1  98              .byte  <(aNop_)       ;    ,
000C9D  1  7C              .byte  <(decr_)       ;    -  ( adr -- ) decrements variable at address
000C9E  1  98              .byte  <(aNop_)       ;    .
000C9F  1  98              .byte  <(aNop_)       ;    /
000CA0  1  98              .byte  <(aNop_)       ;    0
000CA1  1  98              .byte  <(aNop_)       ;    1
000CA2  1  98              .byte  <(aNop_)       ;    2
000CA3  1  98              .byte  <(aNop_)       ;    3
000CA4  1  98              .byte  <(aNop_)       ;    4
000CA5  1  98              .byte  <(aNop_)       ;    5
000CA6  1  98              .byte  <(aNop_)       ;    6
000CA7  1  98              .byte  <(aNop_)       ;    7
000CA8  1  98              .byte  <(aNop_)       ;    8
000CA9  1  98              .byte  <(aNop_)       ;    9
000CAA  1  98              .byte  <(aNop_)       ;    :  start defining a macro
000CAB  1  98              .byte  <(aNop_)       ;    ;
000CAC  1  98              .byte  <(aNop_)       ;    <
000CAD  1  98              .byte  <(aNop_)       ;    =
000CAE  1  98              .byte  <(aNop_)       ;    >( - 1)
000CAF  1  98              .byte  <(aNop_)       ;    ?
000CB0  1  67              .byte  <(cfetch_)     ;    @
000CB1  1  98              .byte  <(aNop_)       ;    A
000CB2  1  32              .byte  <(break_)      ;    B
000CB3  1  98              .byte  <(nop_)        ;    C
000CB4  1  EA              .byte  <(depth_)      ;    D  ( -- val ) depth of data stack
000CB5  1  2B              .byte  <(emit_)       ;    E  ( val -- ) emits a char to output
000CB6  1  98              .byte  <(aNop_)       ;    F
000CB7  1  D0              .byte  <(go_)         ;    G  ( -- ? ) execute mint definition
000CB8  1  21              .byte  <(keyq_)       ;    H  ( verify if key hit )
000CB9  1  76              .byte  <(inPort_)     ;    I  ( port -- val )
000CBA  1  98              .byte  <(aNop_)       ;    J
000CBB  1  21              .byte  <(key_)        ;    K  ( -- val )  read a char from input
000CBC  1  98              .byte  <(aNop_)       ;    L
000CBD  1  98              .byte  <(aNop_)       ;    M
000CBE  1  3E              .byte  <(newln_)      ;    N  ; prints a newline to output
000CBF  1  79              .byte  <(outPort_)    ;    O  ( val port -- )
000CC0  1  54              .byte  <(printStk_)   ;    P  ( -- ) non-destructively prints stack
000CC1  1  98              .byte  <(aNop_)       ;    Q  quits from Mint REPL
000CC2  1  8F              .byte  <(rot_)        ;    R  ( a b c -- b c a )
000CC3  1  98              .byte  <(aNop_)       ;    S
000CC4  1  98              .byte  <(aNop_)       ;    T
000CC5  1  C8              .byte  <(r2s_)        ;    U  S( -- w ) R( w -- )
000CC6  1  BD              .byte  <(s2r_)        ;    V  S( w -- ) R( -- w )
000CC7  1  98              .byte  <(aNop_)       ;    W   ; ( b -- ) if false, skip to end of loop
000CC8  1  CA              .byte  <(exec_)       ;    X
000CC9  1  98              .byte  <(aNop_)       ;    Y
000CCA  1  1B              .byte  <(editDef_)    ;    Z
000CCB  1  C0              .byte  <(cArrDef_)    ;    [
000CCC  1  13              .byte  <(comment_)    ;    \  comment text, skip reading until end of line
000CCD  1  98              .byte  <(aNop_)       ;    ]
000CCE  1  B0              .byte  <(charCode_)   ;    ^
000CCF  1  98              .byte  <(aNop_)       ;    _
000CD0  1  98              .byte  <(aNop_)       ;    `
000CD1  1  96              .byte  <(sysVar_)     ;    a  ; start of data stack *fixed
000CD2  1  96              .byte  <(sysVar_)     ;    b  ; base16 flag
000CD3  1  96              .byte  <(sysVar_)     ;    c  ; TIBPtr variable
000CD4  1  96              .byte  <(sysVar_)     ;    d  ; vDefs variable
000CD5  1  96              .byte  <(sysVar_)     ;    e  ;
000CD6  1  96              .byte  <(sysVar_)     ;    f  ; start of return stack *fixed
000CD7  1  96              .byte  <(sysVar_)     ;    g  ; next dispatcher
000CD8  1  96              .byte  <(sysVar_)     ;    h  ; heap ptr variable
000CD9  1  BD              .byte  <(i_)          ;    i  ; returns index of current loop
000CDA  1  AE              .byte  <(j_)          ;    j  ; returns index of outer loop
000CDB  1  96              .byte  <(sysVar_)     ;    k
000CDC  1  96              .byte  <(sysVar_)     ;    l
000CDD  1  96              .byte  <(sysVar_)     ;    m  ( a b -- c ) return the minimum value
000CDE  1  96              .byte  <(sysVar_)     ;    n
000CDF  1  96              .byte  <(sysVar_)     ;    o
000CE0  1  96              .byte  <(sysVar_)     ;    p
000CE1  1  96              .byte  <(sysVar_)     ;    q
000CE2  1  96              .byte  <(sysVar_)     ;    r  ; return stack pointer
000CE3  1  96              .byte  <(sysVar_)     ;    s  ; data stack pointer
000CE4  1  96              .byte  <(sysVar_)     ;    t
000CE5  1  96              .byte  <(sysVar_)     ;    u
000CE6  1  96              .byte  <(sysVar_)     ;    v
000CE7  1  96              .byte  <(sysVar_)     ;    w
000CE8  1  96              .byte  <(sysVar_)     ;    x
000CE9  1  96              .byte  <(sysVar_)     ;    y
000CEA  1  96              .byte  <(sysVar_)     ;    z
000CEB  1  79              .byte  <(group_)      ;    {
000CEC  1  98              .byte  <(aNop_)       ;    |
000CED  1  A8              .byte  <(endGroup_)   ;    }
000CEE  1  98              .byte  <(aNop_)       ;    ~
000CEF  1  98              .byte  <(aNop_)       ;    BS
000CF0  1               
000CF0  1               ctlcodeshi:
000CF0  1               altcodeshi:
000CF0  1  0F              .byte  >(empty_)      ; NUL ^@
000CF1  1  0F              .byte  >(empty_)      ; SOH ^A
000CF2  1  0F              .byte  >(toggleBase_) ; STX ^B
000CF3  1  0F              .byte  >(empty_)      ; ETX ^C
000CF4  1  0F              .byte  >(empty_)      ; EOT ^D
000CF5  1  0F              .byte  >(edit_)       ; ENQ ^E
000CF6  1  0F              .byte  >(empty_)      ; ACK ^F
000CF7  1  0F              .byte  >(empty_)      ; BEL ^G
000CF8  1  0F              .byte  >(backsp_)     ; BS  ^H
000CF9  1  0F              .byte  >(empty_)      ; TAB ^I
000CFA  1  0F              .byte  >(reedit_)     ; LF  ^J
000CFB  1  0F              .byte  >(empty_)      ; VT  ^K
000CFC  1  0F              .byte  >(list_)       ; FF  ^L
000CFD  1  0F              .byte  >(empty_)      ; CR  ^M
000CFE  1  0F              .byte  >(empty_)      ; SO  ^N
000CFF  1  0F              .byte  >(empty_)      ; SI  ^O
000D00  1  0F              .byte  >(printStack_) ; DLE ^P
000D01  1  0F              .byte  >(empty_)      ; DC1 ^Q
000D02  1  0F              .byte  >(empty_)      ; DC2 ^R
000D03  1  0F              .byte  >(empty_)      ; DC3 ^S
000D04  1  0F              .byte  >(empty_)      ; DC4 ^T
000D05  1  0F              .byte  >(empty_)      ; NAK ^U
000D06  1  0F              .byte  >(empty_)      ; SYN ^V
000D07  1  0F              .byte  >(empty_)      ; ETB ^W
000D08  1  0F              .byte  >(empty_)      ; CAN ^X
000D09  1  0F              .byte  >(empty_)      ; EM  ^Y
000D0A  1  0F              .byte  >(empty_)      ; SUB ^Z
000D0B  1  0F              .byte  >(empty_)      ; ESC ^[
000D0C  1  0F              .byte  >(empty_)      ; FS  ^\
000D0D  1  0F              .byte  >(empty_)      ; GS  ^]
000D0E  1  0F              .byte  >(empty_)      ; RS  ^^
000D0F  1  0F              .byte  >(empty_)      ; US  ^_)
000D10  1  05              .byte  >(aNop_)       ; SP  ^`
000D11  1  04              .byte  >(cstore_)     ;    !
000D12  1  05              .byte  >(aNop_)       ;    "
000D13  1  05              .byte  >(aNop_)       ;    #
000D14  1  05              .byte  >(aNop_)       ;    $  ( -- adr ) text input ptr
000D15  1  05              .byte  >(aNop_)       ;    %
000D16  1  05              .byte  >(aNop_)       ;    &
000D17  1  05              .byte  >(aNop_)       ;    '
000D18  1  0A              .byte  >(ifte_)       ;    (  ( b -- )
000D19  1  05              .byte  >(aNop_)       ;    )
000D1A  1  05              .byte  >(aNop_)       ;    *
000D1B  1  04              .byte  >(incr_)       ;    +  ( adr -- ) increments variable at address
000D1C  1  05              .byte  >(aNop_)       ;    ,
000D1D  1  04              .byte  >(decr_)       ;    -  ( adr -- ) decrements veriable at address
000D1E  1  05              .byte  >(aNop_)       ;    .
000D1F  1  05              .byte  >(aNop_)       ;    /
000D20  1  05              .byte  >(aNop_)       ;    0
000D21  1  05              .byte  >(aNop_)       ;    1
000D22  1  05              .byte  >(aNop_)       ;    2
000D23  1  05              .byte  >(aNop_)       ;    3
000D24  1  05              .byte  >(aNop_)       ;    4
000D25  1  05              .byte  >(aNop_)       ;    5
000D26  1  05              .byte  >(aNop_)       ;    6
000D27  1  05              .byte  >(aNop_)       ;    7
000D28  1  05              .byte  >(aNop_)       ;    8
000D29  1  05              .byte  >(aNop_)       ;    9
000D2A  1  05              .byte  >(aNop_)       ;    :  start defining a macro
000D2B  1  05              .byte  >(aNop_)       ;    ;
000D2C  1  05              .byte  >(aNop_)       ;    <( - 1)
000D2D  1  05              .byte  >(aNop_)       ;    =
000D2E  1  05              .byte  >(aNop_)       ;    >
000D2F  1  05              .byte  >(aNop_)       ;    ?
000D30  1  04              .byte  >(cfetch_)     ;    @
000D31  1  05              .byte  >(aNop_)       ;    A
000D32  1  0A              .byte  >(break_)      ;    B
000D33  1  05              .byte  >(nop_)        ;    C
000D34  1  07              .byte  >(depth_)      ;    D  ( -- val ) depth of data stack
000D35  1  03              .byte  >(emit_)       ;    E  ( val -- ) emits a char to output
000D36  1  05              .byte  >(aNop_)       ;    F
000D37  1  08              .byte  >(go_)         ;    G  ( -- ? ) execute mint definition
000D38  1  03              .byte  >(keyq_)       ;    H  ( verify if key hit )
000D39  1  08              .byte  >(inPort_)     ;    I  ( port -- val )
000D3A  1  05              .byte  >(aNop_)       ;    J
000D3B  1  03              .byte  >(key_)        ;    K  ( -- val )  read a char from input
000D3C  1  05              .byte  >(aNop_)       ;    L
000D3D  1  05              .byte  >(aNop_)       ;    M
000D3E  1  08              .byte  >(newln_)      ;    N  ; prints a newline to output
000D3F  1  08              .byte  >(outPort_)    ;    O  ( val port -- )
000D40  1  08              .byte  >(printStk_)   ;    P  ( -- ) non-destructively prints stack
000D41  1  05              .byte  >(aNop_)       ;    Q  quits from Mint REPL
000D42  1  03              .byte  >(rot_)        ;    R  ( a b c -- b c a )
000D43  1  05              .byte  >(aNop_)       ;    S
000D44  1  05              .byte  >(aNop_)       ;    T
000D45  1  04              .byte  >(r2s_)        ;    U  S( -- w ) R( w -- )
000D46  1  04              .byte  >(s2r_)        ;    V  S( w -- ) R( -- w )
000D47  1  05              .byte  >(aNop_)       ;    W   ; ( b -- ) if false, skip to end of loop
000D48  1  08              .byte  >(exec_)       ;    X
000D49  1  05              .byte  >(aNop_)       ;    Y
000D4A  1  09              .byte  >(editDef_)    ;    Z
000D4B  1  09              .byte  >(cArrDef_)    ;    [
000D4C  1  08              .byte  >(comment_)    ;    \  comment text, skip reading until end of line
000D4D  1  05              .byte  >(aNop_)       ;    ]
000D4E  1  07              .byte  >(charCode_)   ;    ^
000D4F  1  05              .byte  >(aNop_)       ;    _
000D50  1  05              .byte  >(aNop_)       ;    `
000D51  1  07              .byte  >(sysVar_)     ;    a  ; start of data stack *fixed
000D52  1  07              .byte  >(sysVar_)     ;    b  ; base16 flag
000D53  1  07              .byte  >(sysVar_)     ;    c  ; TIBPtr variable
000D54  1  07              .byte  >(sysVar_)     ;    d  ; vDefs variable
000D55  1  07              .byte  >(sysVar_)     ;    e  ;
000D56  1  07              .byte  >(sysVar_)     ;    f  ; start of return stack *fixed
000D57  1  07              .byte  >(sysVar_)     ;    g  ; next dispatcher
000D58  1  07              .byte  >(sysVar_)     ;    h  ; heap ptr variable
000D59  1  0A              .byte  >(i_)          ;    i  ; returns index of current loop
000D5A  1  0A              .byte  >(j_)          ;    j  ; returns index of outer loop
000D5B  1  07              .byte  >(sysVar_)     ;    k
000D5C  1  07              .byte  >(sysVar_)     ;    l
000D5D  1  07              .byte  >(sysVar_)     ;    m  ( a b -- c ) return the minimum value
000D5E  1  07              .byte  >(sysVar_)     ;    n
000D5F  1  07              .byte  >(sysVar_)     ;    o
000D60  1  07              .byte  >(sysVar_)     ;    p
000D61  1  07              .byte  >(sysVar_)     ;    q
000D62  1  07              .byte  >(sysVar_)     ;    r  ; return stack pointer
000D63  1  07              .byte  >(sysVar_)     ;    s  ; data stack pointer
000D64  1  07              .byte  >(sysVar_)     ;    t
000D65  1  07              .byte  >(sysVar_)     ;    u
000D66  1  07              .byte  >(sysVar_)     ;    v
000D67  1  07              .byte  >(sysVar_)     ;    w
000D68  1  07              .byte  >(sysVar_)     ;    x
000D69  1  07              .byte  >(sysVar_)     ;    y
000D6A  1  07              .byte  >(sysVar_)     ;    z
000D6B  1  09              .byte  >(group_)      ;    {
000D6C  1  05              .byte  >(aNop_)       ;    |
000D6D  1  09              .byte  >(endGroup_)   ;    }
000D6E  1  05              .byte  >(aNop_)       ;    ~
000D6F  1  05              .byte  >(aNop_)       ;    BS
000D70  1               
000D70  1               
000D70  1               ; *********************************************************************
000D70  1               ; mint variables, 26 plus 6 from z
000D70  1               vsys:
000D70  1  00 00 00 00          .res GRPSIZE, $0
000D74  1  00 00 00 00  
000D78  1  00 00 00 00  
000DB0  1               
000DB0  1               ; user variable, 26 plus 6 from z
000DB0  1               vars:
000DB0  1  00 00 00 00          .res GRPSIZE, $0
000DB4  1  00 00 00 00  
000DB8  1  00 00 00 00  
000DF0  1               
000DF0  1               ; user function groups, each with 26 plus 6 from Z
000DF0  1               defs:
000DF0  1  00 00 00 00          .res NUMGRPS * GRPSIZE, $00
000DF4  1  00 00 00 00  
000DF8  1  00 00 00 00  
000F30  1               
000F30  1               ; *********************************************************************
000F30  1               ; Macros must be written in Mint and end with ;
000F30  1               ; this code must not span pages
000F30  1               ; *********************************************************************
000F30  1               macros:
000F30  1               
000F30  1               empty_:
000F30  1  3B 00                .asciiz ";"
000F32  1               
000F32  1               backsp_:
000F32  1  5C 63 40 30          .asciiz "\\c@0=0=(1_\\c\\+`\\b \\b`);"
000F36  1  3D 30 3D 28  
000F3A  1  31 5F 5C 63  
000F4A  1               
000F4A  1               reedit_:
000F4A  1  5C 65 5C 40          .asciiz "\\e\\@\\Z;"
000F4E  1  5C 5A 3B 00  
000F52  1               
000F52  1               edit_:
000F52  1  60 3F 60 5C          .asciiz "`?`\\K\\N`> `\\^A-\\Z;"
000F56  1  4B 5C 4E 60  
000F5A  1  3E 20 60 5C  
000F65  1               
000F65  1               list_:
000F65  1  5C 4E 32 36          .asciiz "\\N26(\\i@\\Z\\c@0>(\\N))\\N`> `;"
000F69  1  28 5C 69 40  
000F6D  1  5C 5A 5C 63  
000F81  1               
000F81  1               printStack_:
000F81  1  60 3D 3E 20          .asciiz "`=> `\\P\\N\\N`> `;"
000F85  1  60 5C 50 5C  
000F89  1  4E 5C 4E 60  
000F92  1               
000F92  1               toggleBase_:
000F92  1  5C 62 40 30          .asciiz "\\b@0=\\b!;"
000F96  1  3D 5C 62 21  
000F9A  1  3B 00        
000F9C  1               
000F9C  1               ; heap must be here !
000F9C  1               heap:
000F9C  1  00 00                .addr $0
000F9E  1               
000F9E  1               
